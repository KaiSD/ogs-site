<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Opensource Game Studio</title><link href="http://opengamestudio.org/" rel="alternate"></link><link href="http://opengamestudio.org/feeds/all.atom.xml" rel="self"></link><id>http://opengamestudio.org/</id><updated>2017-11-22T00:00:00+03:00</updated><entry><title>2017 summary</title><link href="http://opengamestudio.org/2017-summary.html" rel="alternate"></link><updated>2017-11-22T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-11-22:2017-summary.html</id><summary type="html">&lt;p&gt;&lt;img alt="Screenshot" src="http://opengamestudio.org/2017-11-22-2017-summary.png" /&gt;&lt;/p&gt;
&lt;p&gt;It's time to step back to see our accomplishments in 2017 and how they connect to the overall goal of Opensource Game Studio project.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Brief history&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Opensource Game Studio project is 12 years old now.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2005.&lt;/strong&gt; We started the project with a &lt;a href="https://www.linuxquestions.org/questions/general-10/the-creation-of-the-best-rpg-355858/"&gt;fanatic call&lt;/a&gt; to create the best game ever. Probably right after finishing Half-Life 2 or Morrowind. 99.99% of those who wanted to participate weathered during a couple of years leaving only the two of us: Michael (coding) and Ivan (the rest).
The project was in a constant turmoil because we had no clear purpose and discipline. Thus, we only got a handful of demonstrations during that period.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2010.&lt;/strong&gt; The first year for us to admit we failed big time. After accepting the failure, we have set Mahjong game as our initial target. We also realized that if we want the game out, we must work every day. We didn't get anywhere by working on weekends because they often collided with family time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2012, 2013.&lt;/strong&gt; We released Mahjong 1.0 and Mahjong 1.1 correspondingly. We created a complete, polished game in 3-4 years after failing to provide anything of value during previous 5 years. To this date, Mahjong is the best and only game we released so far. We're still proud of it because it still feels great.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2015.&lt;/strong&gt; We showcased the first version of our game toolset. After releasing Mahjong, we decided to spend time on building toolset that would allow us to develop games faster.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2016.&lt;/strong&gt; We recreated Mahjong gameplay with our game toolset. However, we quickly realized that desktop only game toolset is a dead end. It led us to research mobile platforms.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Last year&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2016, October.&lt;/strong&gt; We started mobile platforms' research by making simple straightforward  OpenSceneGraph application run under Android.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017, January.&lt;/strong&gt; We got the Android version working and started iOS and Web research.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017, February.&lt;/strong&gt; We made the sample application work everywhere: desktop, mobile, web.&lt;/p&gt;
&lt;p&gt;Researching mobile and web took us about five months. We spent that much time because there was no documentation on how to run OpenSceneGraph across platforms. We had to step in and create said documentation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017, July.&lt;/strong&gt; We published &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide"&gt;OpenSceneGraph cross-platform guide&lt;/a&gt;, which describes how to create a simple OpenSceneGraph application and make it run on desktop, mobile, and web. To this date, this is our most popular GitHub repository.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017, November.&lt;/strong&gt; We published simple &lt;a href="https://ogstudio.github.io/game-memory-colors/tutorial-5.3/mjin-player.html"&gt;Memory: Colors game&lt;/a&gt; and the &lt;a href="https://bitbucket.org/ogstudio-games/memory-colors"&gt;guide&lt;/a&gt; on how to create the game from scratch. The game is powered by MJIN, our new cross-platform game toolset that we started this summer.&lt;/p&gt;
&lt;p&gt;Currently MJIN toolset is in its infancy. MJIN needs a real game to flourish. That's why we are already working on cross-platform Mahjong. We'll do our best to make Mahjong faster this time.&lt;/p&gt;</summary></entry><entry><title>Итоги 2017-го</title><link href="http://opengamestudio.org/2017-summary-ru.html" rel="alternate"></link><updated>2017-11-22T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-11-22:2017-summary-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Screenshot" src="http://opengamestudio.org/2017-11-22-2017-summary.png" /&gt;&lt;/p&gt;
&lt;p&gt;Настало время сделать ревизию наших достижений в 2017 году и проверить, насколько они следуют основной цели проекта Opensource Game Studio.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Краткая история&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Проекту Opensource Game Studio уже 12 лет.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2005.&lt;/strong&gt; Мы начали проект с &lt;a href="https://unixforum.org/index.php?showtopic=9989"&gt;фанатичного призыва&lt;/a&gt; к созданию самой лучшей игры. Видимо, сразу же после прохождения Half-Life 2 или Morrowind. 99.99% тех, кто хотел участвовать, отвалились в течение первых двух лет. Остались лишь два человека: Михаил (программирование) и Иван (всё остальное). Проект находился в стадии постоянного беспорядка, т.к. у нас не было ни чёткой цели, ни дисциплины. Неудивительно, что за этот период мы можем похвастаться лишь небольшим набором сумбурных демонстраций.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2010.&lt;/strong&gt; Первый год признания нашего поражения. После принятия поражения мы поставили себе целью создать игру Маджонг. Мы также осознали, что для выпуска игры нам придётся работать каждый день. Работа по выходным не приносила результатов, т.к. она часто сталкивалась с необходимостью уделять время семье.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2012, 2013.&lt;/strong&gt; Мы выпустили версии 1.0 и 1.1 Маджонга соответственно. Мы создали полноценную отполированную игру за 3-4 года, тогда как до этого 5 лет не могли сделать ничего вразумительного. Маджонг до сих пор остаётся нашей лучшей и единственной выпущенной игрой. Мы всё ещё гордимся им, и нам всё ещё нравится в него играть.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2015.&lt;/strong&gt; Мы продемонстрировали первую версию нашего средства разработки. Мы приступили к его созданию сразу после выпуска Маджонга, т.к. решили сделать инструмент для экономии времени разработки следующих игр.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2016.&lt;/strong&gt; Мы воссоздали игровую механику Маджонга с помощью нашего инструмента. Тем не менее, к тому моменту мы осознали, что разработка лишь под настольные компьютеры нежизнеспособна. Это понимание  подтолкнуло нас к изучению мобильных платформ.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Последний год&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2016, октябрь.&lt;/strong&gt; Мы начали изучение мобильных платформ с создания простейшего приложения OpenSceneGraph, которое сможет работать на Android.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017, январь.&lt;/strong&gt; Мы получили версию Android и начали изучение iOS с Вебом.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017, февраль.&lt;/strong&gt; Мы запустили простейшее приложение везде: настольный компьютер, мобильные платформы, веб.&lt;/p&gt;
&lt;p&gt;Изучение мобильных платформ и веба заняло у нас около пяти месяцев. Нам пришлось потратить это время по причине отсутствия какой-либо внятной документации по работе с OpenSceneGraph на разных платформах. После таких громадных трат времени мы решили сэкономить это время другим разработчикам и занялись созданием указанной документации.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017, июль.&lt;/strong&gt; Мы опубликовали &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide"&gt;инструкцию по работе с OpenSceneGraph на разных платформах&lt;/a&gt;, которая рассказывает в деталях о создании простейшего приложения OpenSceneGraph и запуске его на настольных компьютерах, мобильных платформах и вебе. Эта инструкция является нашим самым популярным проектом на GitHub.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017, ноябрь.&lt;/strong&gt; Мы выпустили простую &lt;a href="https://ogstudio.github.io/game-memory-colors/tutorial-5.3/mjin-player.html"&gt;игру "Память: Цвета"&lt;/a&gt; и &lt;a href="https://bitbucket.org/ogstudio-games/memory-colors"&gt;инструкцию&lt;/a&gt; по созданию этой игры с нуля. Игра создана с помощью MJIN, нашего нового инструмента для разработки игр, этому инструменту всего лишь несколько месяцев.&lt;/p&gt;
&lt;p&gt;На текущий момент MJIN лишь начинает развитие. Этому инструменту нужна настоящая игра, чтобы расцвести. Поэтому мы уже работаем над Маджонгом, который будет радовать вас и на настольных компьютерах, и на мобильных платформах, и в вебе. На этот раз мы постараемся сделать Маджонг быстрее. &lt;/p&gt;</summary></entry><entry><title>Back to the Static</title><link href="http://opengamestudio.org/back-to-the-static.html" rel="alternate"></link><updated>2017-10-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-10-16:back-to-the-static.html</id><summary type="html">&lt;p&gt;&lt;img alt="Back to the Static" src="http://opengamestudio.org/2017-10-16-back-to-the-static.png" /&gt;&lt;/p&gt;
&lt;p&gt;We have been using Wordpress as our website engine for more than seven years. And now it's time to move forward. Or backward.
For some time we've been tracking the development of the new breed of website engines - static site generators.
It seems that this is the technology capable of changing past into future.&lt;/p&gt;
&lt;p&gt;A static website is more straightforward, quicker and more secure. And with the help of generators, it is also as easy to manage, as the dynamic website.
So, we are starting our site anew with the help of the &lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;.
Right now it doesn't have all the content from our old site, but we'll add most of it soon.&lt;/p&gt;</summary></entry><entry><title>Назад в Статику</title><link href="http://opengamestudio.org/back-to-the-static-ru.html" rel="alternate"></link><updated>2017-10-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-10-16:back-to-the-static-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Назад в Статику" src="http://opengamestudio.org/2017-10-16-back-to-the-static.png" /&gt;&lt;/p&gt;
&lt;p&gt;Мы используем Wordpress в качестве движка нашего сайта уже более семи лет. И теперь пришло время двигаться вперед. Или назад.
Некоторое время мы следили за разработкой нового поколения движков - генераторов статических сайтов.
Похоже, что это технология, способная превратить прошлое в будущее.&lt;/p&gt;
&lt;p&gt;Статический веб-сайт проще, быстрее и безопаснее. И с помощью генераторов им настолько же легко управлять, как и динамическим веб-сайтом.
Так что мы начинаем наш сайт заново с помощью [Pelican] (https://blog.getpelican.com/).
Сейчас здесь нет всего контента с нашего старого сайта, но мы добавим его в ближайшее время.&lt;/p&gt;</summary></entry><entry><title>The birth of MJIN world</title><link href="http://opengamestudio.org/mjin-world-birth.html" rel="alternate"></link><updated>2017-09-10T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-09-10:mjin-world-birth.html</id><summary type="html">&lt;p&gt;&lt;img alt="The birth of MJIN world" src="http://opengamestudio.org/2017-09-mjin-world-birth.png" /&gt;&lt;/p&gt;
&lt;p&gt;This article describes the birth of MJIN world in August 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-player&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As you know, &lt;a href="http://opengamestudio.org/scripting-research.html"&gt;we spent July to research scripting&lt;/a&gt;. We found a solution that satisfies the following criteria. Scripts should:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;run unchanged on all supported platforms&lt;/li&gt;
&lt;li&gt;allow extending C++ code&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have verified the second criterion by writing a sample application. The first criterion was taken for granted because it SHOULD be true.&lt;/p&gt;
&lt;p&gt;At the time, we saw two ways to verify the first criterion:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;create one sample application for each platform to verify scripting only&lt;/li&gt;
&lt;li&gt;create a single cross-platform application, which can run any code&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We chose the second approach because it is more beneficial in the long run. As you might have guessed, &lt;a href="https://bitbucket.org/ogstudio/mjin-player"&gt;mjin-player&lt;/a&gt; is that application.&lt;/p&gt;
&lt;p&gt;mjin-player serves as a base for the rest of MJIN projects to make them run on all supported platforms. However, there's no magic trick to hide the projects from the platform, and there was no such intention. Instead, mjin-player provides a consistent set of rules how other MJIN projects should be structured to be able to run on all supported platforms.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-application&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This set of rules for MJIN projects is packaged into &lt;a href="https://bitbucket.org/ogstudio/mjin-application"&gt;mjin-application&lt;/a&gt;. mjin-application is a library that provides basic functionality every MJIN project would need and nothing more. For instance, mjin-application does not and will not contain scripting or any other specific functionality.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MJIN world&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So what is &lt;a href="https://bitbucket.org/ogstudio/mjin"&gt;MJIN world&lt;/a&gt;? It's a set of projects that constitute our game development tools. mjin-player and mjin-application are the first bricks of the newly born MJIN world. A lot more to come. Stay tuned for the brighter MJIN future.&lt;/p&gt;
&lt;p&gt;That's it for describing the birth of MJIN world in August 2017.&lt;/p&gt;</summary></entry><entry><title>Рождение вселенной MJIN</title><link href="http://opengamestudio.org/mjin-world-birth-ru.html" rel="alternate"></link><updated>2017-09-10T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-09-10:mjin-world-birth-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Рождение вселенной MJIN" src="http://opengamestudio.org/2017-09-mjin-world-birth.png" /&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает рождение вселенной MJIN в августе 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-player&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Как вы знаете, &lt;a href="http://opengamestudio.org/scripting-research-ru.html"&gt;в июле мы изучали скриптование&lt;/a&gt;. Мы нашли решение, которое удовлетворяет следующим критериям. Скрипты должны:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;исполняться в исходном виде без изменений на всех поддерживаемых платформах&lt;/li&gt;
&lt;li&gt;позволять расширять код C++&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Мы проверили второй критерий в рамках тестового приложения. В первый критерий мы просто поверили, т.к. он ДОЛЖЕН быть верен.&lt;/p&gt;
&lt;p&gt;В тот момент мы видели два варианта проверки первого критерия:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;создать по одному тестовому приложению под каждую платформу для проверки лишь этого критерия&lt;/li&gt;
&lt;li&gt;создать одно кросс-платформенное приложение, которому можно скормить практически любой код&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Мы выбрали второй подход, т.к. он выгоднее в долгосрочной перспективе. Как вы уже догадались, &lt;a href="https://bitbucket.org/ogstudio/mjin-player"&gt;mjin-player&lt;/a&gt; является тем самым кросс-платформенным приложением.&lt;/p&gt;
&lt;p&gt;mjin-player служит базой для остальных проектов MJIN, которая позволяет этим проектам работать на всех поддерживаемых платформах. Тем не менее, в mjin-player нет никакой магии, проекты никак не скрыты от деталей платформ, да и не было такой задачи. Вместо скрытия деталей платформы mjin-player предоставляет набор правил, которым должны удовлетворять проекты MJIN для работы на всех поддерживаемых платформах.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-application&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Этот набор правил представлен в виде &lt;a href="https://bitbucket.org/ogstudio/mjin-application"&gt;mjin-application&lt;/a&gt;. mjin-application является библиотекой с базовым функционалом, необходимым для каждого проекта MJIN, но не более. Например, mjin-application не содержит и никогда не будет содержать скриптования или подобного специфического функционала.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Вселенная MJIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Так что же такое &lt;a href="https://bitbucket.org/ogstudio/mjin"&gt;вселенная MJIN&lt;/a&gt;? Это множество проектов, которые являются нашими средствами для разработки игр. mjin-player и mjin-application - первые кирпичики недавно появившейся вселенной MJIN. А будет их намного больше. Оставайтесь на связи, нас ждёт светлое будущее с MJIN.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем описание рождения вселенной MJIN в августе 2017.&lt;/p&gt;</summary></entry><entry><title>Scripting research</title><link href="http://opengamestudio.org/scripting-research.html" rel="alternate"></link><updated>2017-08-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-08-16:scripting-research.html</id><summary type="html">&lt;p&gt;&lt;img alt="Scripting research" src="http://opengamestudio.org/2017-08-scripting-research.png" /&gt;&lt;/p&gt;
&lt;p&gt;This article describes scripting research in July 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Our first goal of using a scripting language was to have a platform-independent code that runs unchanged on every supported platform.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OGS Editor 0.10 supports Python for such a code thanks to &lt;a href="http://swig.org/"&gt;SWIG&lt;/a&gt;. SWIG provides a way to wrap almost any C/C++ code and use it in dozens of languages like Python, Ruby, Lua, Java, C#, etc.. SWIG really helped us taste the beauty of platform-independent code. However, SWIG only works one way: from C/C++ to a target language. This means the main application must be in the target language, and C/C++ code can only be used as a library.&lt;/p&gt;
&lt;p&gt;Having the main application in Python works fine for the desktop, but not so great for mobile and web, where C and C++ are the only natively supported cross-platform languages. There are projects like &lt;a href="https://kivy.org"&gt;Kivy&lt;/a&gt;, which allow you to develop cross-platform applications in Python, but they are not supported natively. This means it's a lot of headaches when Android and iOS APIs change.&lt;/p&gt;
&lt;p&gt;Having the main application in C/C++ and the need to support scripting means that a scripting language should be interpreted by the application. This is what SWIG, Kivy, and similar projects are not meant to fulfill.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Our secondary goal for using a scripting language was to allow to extend C++ code.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OGS Editor 0.10 has some modules written in C++, and some in Python. The modules are equal from the perspective of the main application; it doesn't care what language the module is written in.&lt;/p&gt;
&lt;p&gt;To achieve such flexibility, we introduced a so-called Environment. Each module would register the keys it responds to, and Environment would deliver corresponding messages. 
Technically such behaviour is achieved by inheriting a base class and overriding its methods in both C++ and a scripting language.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First, we evaluated Python for the role of cross-platform scripting language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Since we already used Python, we started to research the possibility to run Python code on every supported platform. The result was disappointing because CPython (the default Python implementation used on the desktop) does not mention mobile and web platforms. We only found some years old forks of CPython that were claimed to work either on Android or iOS. Such a disarray was not suitable for us.
We also had a look at &lt;a href="http://pypy.org"&gt;PyPy&lt;/a&gt;, another Python implementation. It also did not mention support for mobile and web platforms.&lt;/p&gt;
&lt;p&gt;This was a clear indication that Python community doesn't care for mobile and web platforms. Or that nobody had time to provide the information about building Python on such platforms. Either way, it was not acceptable for us.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Second, we evaluated &lt;a href="http://wren.io"&gt;Wren&lt;/a&gt; for the role of cross-platform scripting language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Wren was the first scripting language we stumbled upon in the long list of non-mainstream scripting languages.&lt;/p&gt;
&lt;p&gt;Wren claimed to be small and easy to learn. Wren also claimed to be intended for embedding in applications. Ironically, the author &lt;a href="http://wren.io/embedding-api.html"&gt;had no time to document how to do the embedding in the first place&lt;/a&gt;. When &lt;a href="https://github.com/munificent/wren/issues/465"&gt;we asked for the time estimates of publishing&lt;/a&gt; the critical part of the documentation, &lt;a href="https://github.com/munificent/wren/issues/402"&gt;we just got a reference to another issue&lt;/a&gt; where the other guy was asking the same question half a year ago!&lt;/p&gt;
&lt;p&gt;That's when we ended our relationship with Wren.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Third, we evaluated &lt;a href="http://chaiscript.com"&gt;Chai&lt;/a&gt; for the role of cross-platform scripting language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Chai was in the long list of non-mainstream scripting languages, too. Chai was promising because it claimed to be specifically tailored for embedding in a C++ application.
We successfully managed to call a C++ function from inside Chai but failed to call a member function. &lt;a href="http://discourse.chaiscript.com/t/cannot-call-a-function-that-accepts-a-string-and-a-vector/334"&gt;We asked for help&lt;/a&gt;, but nobody replied.&lt;/p&gt;
&lt;p&gt;We had to end our relationship with Chai.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fourth, we evaluated Lua for the role of cross-platform scripting language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lua is the mainstream language for embedding. So we decided to try the obvious choice. Documentation looked promising, too. However, by the end of reading the &lt;a href="https://www.lua.org/pil/24.html"&gt;C API&lt;/a&gt; chapter we had no clue how to inherit a class inside Lua.&lt;/p&gt;
&lt;p&gt;This led us to search for libraries that wrap Lua C API syntax into something more meaningful for C++. That's how we found &lt;a href="http://sol2.rtfd.io"&gt;Sol2&lt;/a&gt;. Just as before, the first attempt to call a C++ member function from Lua failed. But unlike before, we asked for help and &lt;a href="https://github.com/ThePhD/sol2/issues/465"&gt;got the help&lt;/a&gt;! This was a refreshing surprise for us.
Next, we tried to inherit a class in Lua and override the class methods. We failed, but &lt;a href="https://github.com/ThePhD/sol2/issues/468"&gt;the author helped us out again&lt;/a&gt;. In the end, we succeeded in inheriting a class and overriding its behaviour.&lt;/p&gt;
&lt;p&gt;That's when we understood it's a start for a long and mutual relationship with Sol2/Lua.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This search for a scripting language taught us one important lesson: people matter, not technologies.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There are lots of scripting languages that look shiny on the outside but are dead. Why? Because some authors don't have time for users. In return, users don't have time for the authors' projects.&lt;/p&gt;
&lt;p&gt;That's it for describing scripting research in July 2017.&lt;/p&gt;</summary></entry><entry><title>Изучение скриптования</title><link href="http://opengamestudio.org/scripting-research-ru.html" rel="alternate"></link><updated>2017-08-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-08-16:scripting-research-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Изучение скриптования" src="http://opengamestudio.org/2017-08-scripting-research.png" /&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает изучение скриптования в июле 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Наша основная цель использования скриптового языка - это наличие платформо-независимого кода, выполняемого без изменений на каждой поддерживаемой платформе.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Редактор 0.10 использует Python в качестве подобного кода с помощью &lt;a href="http://swig.org/"&gt;SWIG&lt;/a&gt;. SWIG позволяет использовать практически любой код C/C++ из языков вроде Python, Ruby, Lua, Java, C# и т.д.. SWIG помог нам впервые оценить прелесть платформо-независимого кода. К сожалению, SWIG работает лишь в одном направлении: из C/C++ в язык назначения. Это приводит к тому, что основное приложение должно быть написано на языке назначения, а код C/C++ может быть использован лишь в виде библиотеки.&lt;/p&gt;
&lt;p&gt;Основное приложение на языке Python вполне подходит для десктопа, но не для мобилок и веба, где языки C и C++ являются единственными языками, поддерживаемыми нативно на каждой платформе. Конечно, существуют проекты вроде &lt;a href="https://kivy.org"&gt;Kivy&lt;/a&gt;, которые позволяет разрабатывать кросс-платформенные приложения на Python, но они не поддерживаются нативно. Отсутствие нативной поддержки выливается в огромную головную боль при изменении API у Android и iOS.&lt;/p&gt;
&lt;p&gt;Необходимость в приложении на C/C++ и поддержке скриптов приводит к обязательному интерпретированию скриптового языка самим приложением. Это как раз то, что SWIG, Kivy и подобные проекты не позволяют сделать.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Наша вторичная цель использования скриптового языка - это возможность расширения кода C++.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Одни модули Редактора 0.10 написаны на C++, а другие на Python. С точки зрения основного приложения, все модули равны. Для приложения нет никакой разницы, на каком языке написан конкретный модуль.&lt;/p&gt;
&lt;p&gt;Для достижения этой гибкости мы ввели так называемое Окружение (Environment). Каждый модуль регистрирует ключи (keys), на которые он отвечает, а Окружение доставляет соответствующие сообщения. Технически такое поведение можно достигнуть с помощью наследования базового класса и переопределения его методов как в C++, так и в скриптовом языке.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python был первым языком, который мы рассмотрели в качестве платформо-независимого скриптового языка.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Т.к. мы уже использовали Python, то логично было начать изучение с него. Мы хотели проверить, можно ли запустить код Python на каждой поддерживаемой платформе. К сожалению, результаты были удручающими, т.к. документация CPython (реализация Python, используемая по умолчанию на десктопе) никак не упоминала ни мобилки, ни веб. Всё, что мы нашли, - это пара форков CPython лохматых годов, которые якобы работают либо на Android, либо на iOS. Такой раздрай нас не устроил.
Мы также рассмотрели &lt;a href="http://pypy.org"&gt;PyPy&lt;/a&gt;, ещё одну реализацию Python, но она тоже не содержала информации о мобилках и вебе.&lt;/p&gt;
&lt;p&gt;Это было чётким сигналом об отсутствии интереса к мобилками и вебу со стороны сообщества Python. Либо об отсутствии времени даже на то, чтобы описать использование Python на данных платформах. В любом случае, такое положение вещей нас не устроило.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://wren.io"&gt;Wren&lt;/a&gt; был вторым языком, который мы рассмотрели в качестве платформо-независимого скриптового языка.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Wren был первым языком из длинного списка малоизвестных скриптовых языков.&lt;/p&gt;
&lt;p&gt;Wren преподносился как небольшой и простой язык. Согласно документации, основная цель Wren - это быть встроенным в приложение. По иронии судьбы, у автора &lt;a href="http://wren.io/embedding-api.html"&gt;не было времени описать в документации встраивание Wren&lt;/a&gt; в приложение. Когда мы &lt;a href="https://github.com/munificent/wren/issues/465"&gt;спросили о сроках публикации&lt;/a&gt; этой критически важной части документации, мы &lt;a href="https://github.com/munificent/wren/issues/402"&gt;получили в ответ ссылку на тикет&lt;/a&gt;, в котором другой человек спрашивал тот же самый вопрос полгода назад!&lt;/p&gt;
&lt;p&gt;На этом мы закончили отношения с Wren.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://chaiscript.com"&gt;Chai&lt;/a&gt; был третьим языком, который мы рассмотрели в качестве платформо-независимого скриптового языка.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Chai был в том же длинном списке малоизвестных скриптовых языков. Он преподносился как язык, специально предназначенный для встраивания в приложения C++. Мы без проблем вызвали функцию C++ из Chai, но нам не удалось вызвать метод класса. &lt;a href="http://discourse.chaiscript.com/t/cannot-call-a-function-that-accepts-a-string-and-a-vector/334"&gt;Мы попросили о помощи&lt;/a&gt;, но ответом была лишь тишина.&lt;/p&gt;
&lt;p&gt;Нам пришлось завершить отношения с Chai.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua был четвёртым языком, который мы рассмотрели в качестве платформо-независимого скриптового языка.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lua является популярным языком для встраивания. Мы решили попробовать очевидный вариант. Документация выглядела многообещающе, однако под конец чтения главы &lt;a href="https://www.lua.org/pil/24.html"&gt;C API&lt;/a&gt; у нас не было ни малейшего представления, как наследовать класс C++ в Lua.&lt;/p&gt;
&lt;p&gt;Этот вопрос заставил нас найти библиотеку, которая смогла бы на него ответить: &lt;a href="http://sol2.rtfd.io"&gt;Sol2&lt;/a&gt;. Первая попытка вызвать функцию C++ из Lua провалилась. Правда, на этот раз наш вопрос был услышан, и &lt;a href="https://github.com/ThePhD/sol2/issues/465"&gt;мы получили ответ&lt;/a&gt;! Мы были сильно удивлены.
Далее мы попытались наследовать класс C++ в Lua, чтобы переопределить методы класса. Нам это не удалось с первого раза, но автор Sol2 &lt;a href="https://github.com/ThePhD/sol2/issues/468"&gt;снова помог нам&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В тот момент мы поняли, что это начало долгого и взаимовыгодного сотрудничества с Sol2/Lua.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Поиск скриптового языка открыл для нас следующую истину: люди важнее технологий.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Существует множество скриптовых языков, которые выглядят привлекательно на первый взгляд, но которые мертвы. Почему? Потому что у некоторых авторов нет времени на пользователей. В ответ пользователи предпочитают не тратить своё время на проекты подобных авторов.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем описание изучения скриптования в июле 2017.&lt;/p&gt;</summary></entry><entry><title>OpenSceneGraph cross-platform guide</title><link href="http://opengamestudio.org/openscenegraph-cross-platform-guide.html" rel="alternate"></link><updated>2017-07-17T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-07-17:openscenegraph-cross-platform-guide.html</id><summary type="html">&lt;p&gt;&lt;img alt="OpenSceneGraph guide" src="http://opengamestudio.org/2017-07-openscenegraph-guide.png" /&gt;&lt;/p&gt;
&lt;p&gt;This article summarizes the work we did to produce OpenSceneGraph cross-platform guide.&lt;/p&gt;
&lt;p&gt;June marked the finish of &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide"&gt;OpenSceneGraph cross-platform guide&lt;/a&gt; with the publishing of the last (initially planned) tutorial. The tutorial describes &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/tree/master/1.10.SampleWeb"&gt;how to build and run sample OpenSceneGraph application in Web&lt;/a&gt; using Emscripten.
In case you missed it, here's a &lt;a href="https://ogstudio.github.io/openscenegraph-cross-platform-guide/"&gt;link to the final application&lt;/a&gt;. Open it in your web browser.&lt;/p&gt;
&lt;p&gt;We started to compose the guide in February when we successfully managed to render a simple model on mobile and web.
We spent 120 hours in five months to produce ten tutorials of the guide.&lt;/p&gt;
&lt;p&gt;We have been doing OpenSceneGraph cross-platform guide for two main reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Keep OpenSceneGraph cross-platform knowledge in easily accessible and reproducible form&lt;/li&gt;
&lt;li&gt;Share the knowledge with OpenSceneGraph community to make it stronger&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We believe we succeeded in both. Here's why:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The guide repository has more &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/stargazers"&gt;stars&lt;/a&gt; (aka "likes") than any other repository of ours&lt;/li&gt;
&lt;li&gt;OpenSceneGraph project leader Robert Osfield said &lt;a href="http://www.mail-archive.com/osg-users@lists.openscenegraph.org/msg74815.html"&gt;"Great work"&lt;/a&gt;, which means a lot&lt;/li&gt;
&lt;li&gt;The guide already has &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/issues"&gt;two issues&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Reaching our goal of researching OpenSceneGraph cross-platform development and providing the knowledge back to the community just made us happier.&lt;/p&gt;
&lt;p&gt;However, our journey does not stop here. Using the knowledge of the guide, we now continue to work on bringing our tools to support mobile and web, just as we &lt;a href="http://opengamestudio.org/lang/en/news/2456"&gt;promised in January&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That's it for summarizing the work we did to produce OpenSceneGraph cross-platform guide.&lt;/p&gt;</summary></entry><entry><title>OpenSceneGraph cross-platform guide</title><link href="http://opengamestudio.org/openscenegraph-cross-platform-guide-ru.html" rel="alternate"></link><updated>2017-07-17T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-07-17:openscenegraph-cross-platform-guide-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="OpenSceneGraph guide" src="http://opengamestudio.org/2017-07-openscenegraph-guide.png" /&gt;&lt;/p&gt;
&lt;p&gt;Эта статья резюмирует создание кросс-платформенного руководства OpenSceneGraph.&lt;/p&gt;
&lt;p&gt;Июнь ознаменовал собой окончание работы над &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide"&gt;кросс-платформенным руководством OpenSceneGraph&lt;/a&gt;. Мы опубликовали последний самоучитель (из изначально запланированных). Этот самоучитель описывает &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/tree/master/1.10.SampleWeb"&gt;сборку и запуск примера приложения OpenSceneGraph в вебе&lt;/a&gt; с помощью Emscripten.
Если вы упустили этот самоучитель, то вот &lt;a href="https://ogstudio.github.io/openscenegraph-cross-platform-guide/"&gt;ссылка на приложение&lt;/a&gt; из него. Откройте ссылку в веб-браузере.&lt;/p&gt;
&lt;p&gt;Мы начали составление руководства в феврале, как только нам удалось отобразить простую модель на мобилках и вебе.
Мы потратили 120 часов за пять месяцев на составление десяти самоучителей этого руководства.&lt;/p&gt;
&lt;p&gt;Создание кросс-платформенного руководства OpenSceneGraph преследовало две основные цели:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Сохранить знания о кросс-платформенной работе с OpenSceneGraph в легкодоступной и воспроизводимой форме&lt;/li&gt;
&lt;li&gt;Поделиться этим знанием с сообществом OpenSceneGraph и тем самым усилить сообщество&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Мы уверены в том, что нам удалось достичь обе цели. И вот почему:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Хранилище руководства получило больше &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/stargazers"&gt;звёзд&lt;/a&gt; (лайков), чем любое другое наше хранилище&lt;/li&gt;
&lt;li&gt;Robert Osfield, лидер проекта OpenSceneGraph, оценил руководство как &lt;a href="http://www.mail-archive.com/osg-users@lists.openscenegraph.org/msg74815.html"&gt;"отличную работу"&lt;/a&gt;; это значит для нас многое&lt;/li&gt;&lt;/li&gt;
&lt;li&gt;У руководства уже есть &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/issues"&gt;два тикета&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;В конце концов, мы просто рады тому факту, что изучили кросс-платформенную разработку с OpenSceneGraph и поделились этим знанием с сообществом.&lt;/p&gt;
&lt;p&gt;Тем не менее, наше путешествие на этом не окончено. Используя знания руководства, мы продолжаем работу над тем, чтобы добавить в свои инструменты поддержку мобилок и веба, как мы &lt;a href="http://opengamestudio.org/lang/ru/news/2456"&gt;обещали в январе&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем резюме о создании кросс-платформенного руководства OpenSceneGraph.&lt;/p&gt;</summary></entry><entry><title>iOS tutorial</title><link href="http://opengamestudio.org/ios-tutorial.html" rel="alternate"></link><updated>2017-06-08T10:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-06-08:ios-tutorial.html</id><summary type="html">&lt;p&gt;&lt;img alt="iOS tutorial" src="http://opengamestudio.org/2017-06-08-ios-refactoring.png" /&gt;&lt;/p&gt;
&lt;p&gt;This article describes problems we faced during the creation of iOS tutorial in May 2017.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twitter.com/OpenGameStudio/status/826816343433498627"&gt;This February&lt;/a&gt; we managed to get simple model rendered under iOS in just a few days. We expected to finish iOS tutorial in no time. However, the reality reminded us: it's easy to come up with a hackish demo that works for one person, but it's hard to create a concise example that works for everyone.&lt;/p&gt;
&lt;h3&gt;Native library&lt;/h3&gt;
&lt;p&gt;The first question we had to answer was: should the sample application be part of Xcode project or be a separately built library?&lt;/p&gt;
&lt;p&gt;We had to consider the following facts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Xcode project can use C++ directly (thanks to Objective-C++) without stuff like JNI&lt;ul&gt;
&lt;li&gt;There's no need for a separate library (+ application)&lt;/li&gt;
&lt;li&gt;Creating a separate library is an additional work (- library)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSceneGraph builds libraries&lt;ul&gt;
&lt;li&gt;It's easier to use standard build process (+ library)&lt;/li&gt;
&lt;li&gt;It's harder to create custom build process just for a single platform (- application)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSceneGraph uses CMake build system, which is not supported by Xcode&lt;ul&gt;
&lt;li&gt;Xcode project can't include CMake files (- application)&lt;/li&gt;
&lt;li&gt;It's easy to create custom CMake file that includes OpenSceneGraph CMake file to build a single library (+ library)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMake can generate Xcode project&lt;ul&gt;
&lt;li&gt;It's possible to create a CMake file that builds both OpenSceneGraph and the sample application (+ application)&lt;/li&gt;
&lt;li&gt;Xcode is the de-facto tool to create Xcode projects; it's easier to use standard build process (+ library)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After evaluating the pros and cons of each approach, we decided to turn the sample application into a library and include it in Xcode project. The downside of this approach is that simulator and real device builds need separate library builds.&lt;/p&gt;
&lt;h3&gt;Refactoring&lt;/h3&gt;
&lt;p&gt;The second question we had to answer was: should there be a single source code base for all platforms or several ones, one for each platform?&lt;/p&gt;
&lt;p&gt;While doing Android tutorial we used single source code base because it worked fine for desktop and Android. As we started to work through iOS tutorial, it became apparent that particular features may or may not work on some platforms. For example, one feature may work on desktop and iOS, but not Android. Another feature may work on iOS and Android, but not desktop. Since we didn't want to pollute the code with #ifdefs, we started to put each platform combination into a separate file. The number of files grew rapidly. The files were reusable, but it became extremely hard to see the whole picture.&lt;/p&gt;
&lt;p&gt;At this point, we realized there's the second question. We reminded ourselves that the main purpose of the sample source code is to teach how to do basic OpenSceneGraph things, not create a reusable library with API that is stable across several years.&lt;/p&gt;
&lt;p&gt;That's when our home grown feature tool came into play. With its help, we separated the code into several parts, which in the end produce just two files for each platform:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;functions.h - contains reusable classless functions&lt;/li&gt;
&lt;li&gt;main.h - contains the rest of the sample application code&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Their contents differ slightly for each platform, but it's easy to see the whole picture now.&lt;/p&gt;
&lt;p&gt;That's it for describing problems we faced during the creation of iOS tutorial in May 2017.&lt;/p&gt;</summary></entry><entry><title>Самоучитель iOS</title><link href="http://opengamestudio.org/ios-tutorial-ru.html" rel="alternate"></link><updated>2017-06-08T10:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-06-08:ios-tutorial-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Самоучитель iOS" src="http://opengamestudio.org/2017-06-08-ios-refactoring.png" /&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает проблемы, с которыми мы столкнулись во время создания самоучителя для iOS в мае 2017.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twitter.com/OpenGameStudio/status/826816343433498627"&gt;В феврале&lt;/a&gt; мы сумели отобразить простую модель под iOS за считанные дни. Это дало нам уверенность, что самоучитель для iOS мы сделаем столь же быстро. Тем не менее, реальность напомнила нам о простой вещи: быстро сделать можно лишь поделку на коленке, работающую только у самого разработчика; над логически связанным примером, работающим у всех, придётся попотеть.&lt;/p&gt;
&lt;h3&gt;Нативная библиотека&lt;/h3&gt;
&lt;p&gt;Прежде всего нам необходимо было ответить на следующий вопрос: "должен ли пример приложения быть частью проекта Xcode или отдельной библиотекой?"&lt;/p&gt;
&lt;p&gt;Для принятия решения мы использовали следующие факты:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Проект Xcode может напрямую использовать C++ (благодаря Objective-C++) без прослоек вроде JNI&lt;ul&gt;
&lt;li&gt;Отдельная библиотека не нужна (+ приложение)&lt;/li&gt;
&lt;li&gt;Создание отдельной библиотеки - это дополнительная работа (- библиотека)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSceneGraph собирается в библиотеки&lt;ul&gt;
&lt;li&gt;Легче использовать стандартный процесс сборки (+ библиотека)&lt;/li&gt;
&lt;li&gt;Создавать свой процесс сборки лишь для одной платформы сложно (- приложение)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSceneGraph использует систему сборки CMake, которая не поддерживается Xcode&lt;ul&gt;
&lt;li&gt;Проект Xcode не может включать файлы CMake (- приложение)&lt;/li&gt;
&lt;li&gt;Свой файл CMake может с лёгкостью включить файл OpenSceneGraph CMake для сборки единой библиотеки (+ библиотека)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMake может генерировать проект Xcode&lt;ul&gt;
&lt;li&gt;Можно создать файл CMake, который будет собирать как OpenSceneGraph, так и пример приложения (+ приложение)&lt;/li&gt;
&lt;li&gt;Xcode - это де-факто инструмент для создания проектов Xcode; легче использовать стандартный процесс сборки (+ библиотека)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Оценив плюсы и минусы обоих подходов, мы решили сделать библиотеку, которую можно включать в проект Xcode. Минусом данного подхода является то, что сборки приложения для симулятора и реального устройства используют разные сборки библиотеки.&lt;/p&gt;
&lt;h3&gt;Рефакторинг&lt;/h3&gt;
&lt;p&gt;Также нам пришлось ответить на ещё один вопрос: "использовать ли единую кодовую базу для всех платформ или несколько под каждую платформу?"&lt;/p&gt;
&lt;p&gt;При создании самоучителя для Android мы использовали единую кодовую базу, т.к. она отлично работала для десктопа и Android. Когда мы начали работу над самоучителем iOS, стало ясно, что часть функционала либо работает, либо не работает на некоторых платформах. Например, один функционал может работать на десктопе и iOS, но не работать на Android. Другой функционал может работать на iOS и Android, но не работать на десктопе. Т.к. мы не хотели загрязнять код кучей #ifdef, мы решили помещать функционал, специфичный для конкретной платформы или нескольких платформ, в разные файлы. Это привело к резкому увеличению количества файлов. Такой подход хорошо подходил для повторного использования, но совершенно не годился для понимания общей картины.&lt;/p&gt;
&lt;p&gt;В этот момент мы осознали необходимость ответа на второй вопрос. Мы напомнили себе, что главная цель примера приложения состоит в том, чтобы обучить базовым вещам OpenSceneGraph, а не создать повторно используемую библиотеку с API, который будет жить без изменений десятилетиями.&lt;/p&gt;
&lt;p&gt;Для ответа на этот вопрос нам помог наш внутренний инструмент feature tool. С его помощью мы разделили код на несколько частей, который в итоге собирается ровно в два файла для каждой платформы:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;functions.h - содержит повторно используемые бесклассовые функции&lt;/li&gt;
&lt;li&gt;main.h - содержит остальной код приложения&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Их содержимое несколько отличается для каждой из платформ, но наличие всего двух файлов позволяет увидеть общую картину.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем описание проблем, с которыми мы столкнулись во время создания самоучителя для iOS в мае 2017.&lt;/p&gt;</summary></entry><entry><title>OpenSceneGraph sample</title><link href="http://opengamestudio.org/osg-sample.html" rel="alternate"></link><updated>2017-05-12T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-05-12:osg-sample.html</id><summary type="html">&lt;p&gt;&lt;img alt="OSG sample" src="http://opengamestudio.org/2017-05_osg-sample.png" /&gt;&lt;/p&gt;
&lt;p&gt;This article describes creation of the tutorials for building sample OpenSceneGraph application under Linux, macOS, Windows, and Android in April 2017.&lt;/p&gt;
&lt;p&gt;Previous tutorials described how to install OpenSceneGraph under Linux, macOS, Windows and render a model using the standard &lt;strong&gt;osgviewer&lt;/strong&gt; tool. This time we worked on a &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide-application"&gt;sample OpenSceneGraph application&lt;/a&gt; that would run under Linux, macOS, Windows, and Android.&lt;/p&gt;
&lt;p&gt;The application is very basic and has the following features:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Render window creation&lt;/li&gt;
&lt;li&gt;Model loading&lt;/li&gt;
&lt;li&gt;Model rendering with simple GLSL shaders&lt;/li&gt;
&lt;li&gt;Model motion with a mouse under Linux, macOS, Windows and a finger under Android&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Creating the tutorials for Linux, macOS, Windows was so easy and straightforward, that it only took us half a month. We spent the second half of the month creating Android tutorial.&lt;/p&gt;
&lt;p&gt;Our &lt;a href="http://opengamestudio.org/2016-october-recap.html"&gt;first successful Android build&lt;/a&gt; last year included hacks and non-obvious steps to make OpenSceneGraph run under Android. This time we wanted a cleaner, faster, and cheaper approach.&lt;/p&gt;
&lt;p&gt;The approach we ended up with requires just a few files and a few changes to the original Android Studio project (with C++ support) to make sample OpenSceneGraph application run under Android.&lt;/p&gt;
&lt;p&gt;Here's a quick rundown of the files:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GLES2 surface&lt;/li&gt;
&lt;li&gt;Render activity to render to the surface&lt;/li&gt;
&lt;li&gt;Native library Java interface&lt;/li&gt;
&lt;li&gt;Native library C++ implementation&lt;/li&gt;
&lt;li&gt;CMake file to build native library&lt;/li&gt;
&lt;li&gt;Render activity layout&lt;/li&gt;
&lt;li&gt;Model to display&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here's a quick rundown of the project changes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Update Android manifest to use GLES2 and render activity&lt;/li&gt;
&lt;li&gt;Reference native library's CMake file in the project's CMake file&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OpenSceneGraph documentation suggests building OpenSceneGraph outside Android Studio with CMake. However, this approach has the following limitations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;You have to build OpenSceneGraph for each target architecture&lt;/li&gt;
&lt;li&gt;You have to manually copy/reference built OpenSceneGraph libraries into Android Studio project&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Our approach includes building OpenSceneGraph for those target architectures that Android Studio project is built for. Also, OpenSceneGraph is already referenced, so no extra work is required: you just need to rebuild the project, and you're done.&lt;/p&gt;
&lt;p&gt;That's it for describing the creation of the tutorials for building sample OpenSceneGraph application under Linux, macOS, Windows, and Android in April 2017.&lt;/p&gt;</summary></entry><entry><title>Приложение OpenSceneGraph</title><link href="http://opengamestudio.org/osg-sample-ru.html" rel="alternate"></link><updated>2017-05-12T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-05-12:osg-sample-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="OSG sample" src="http://opengamestudio.org/2017-05_osg-sample.png" /&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает создание самоучителей по сборке приложения OpenSceneGraph на Linux, macOS, Windows и Android в апреле 2017.&lt;/p&gt;
&lt;p&gt;Предыдущие самоучители описывали установку OpenSceneGraph на Linux, macOS, Windows и отображение модели с помощью стандартного инструмента &lt;strong&gt;osgviewer&lt;/strong&gt;. На этот раз результатом нашей работы стало &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide-application"&gt;приложение OpenSceneGraph&lt;/a&gt;, которое работает на Linux, macOS, Windows и Android.&lt;/p&gt;
&lt;p&gt;Приложение очень простое. Оно умеет следующее:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Создание окна для отрисовки&lt;/li&gt;
&lt;li&gt;Загрузка модели&lt;/li&gt;
&lt;li&gt;Отрисовка модели с помощью простых шейдеров GLSL&lt;/li&gt;
&lt;li&gt;Перемещение модели с помощью мыши на Linux, macOS, Windows и пальца на Android&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Создать самоучители для Linux, macOS, Windows было настолько простой и понятной задачей, что мы справились с ней за пару недель. Оставшуюся половину месяца мы потратили на создание самоучителя для Android.&lt;/p&gt;
&lt;p&gt;Наша &lt;a href="http://opengamestudio.org/2016-october-recap-ru.html"&gt;первая успешная сборка под Android&lt;/a&gt; в прошлом году требовала множество неочивидных телодвижений. В этот раз мы хотели получить более чистый, быстрый и дешёвый подход.&lt;/p&gt;
&lt;p&gt;Нам это удалось. В результате всё, что нужно для работы приложения OpenSceneGraph на Android, уместилось в набор из нескольких файлов и небольших изменений для стандартного проекта Android Studio (с поддержкой C++).&lt;/p&gt;
&lt;p&gt;Краткий перечень файлов:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Поверхность GLES2&lt;/li&gt;
&lt;li&gt;Activity для отрисовки на этой поверхности&lt;/li&gt;
&lt;li&gt;Интерфейс Java для нативной библиотеки&lt;/li&gt;
&lt;li&gt;Реализация нативной библиотеки на C++&lt;/li&gt;
&lt;li&gt;Файл CMake для сборки нативной библиотеки&lt;/li&gt;
&lt;li&gt;Activity layout&lt;/li&gt;
&lt;li&gt;Модель для отрисовки&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Краткий перечень изменений проекта:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Обновление Android manifest для использования GLES2 и Activity&lt;/li&gt;
&lt;li&gt;Использование файла CMake нативной библиотеки в проектном файле CMake&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Документация OpenSceneGraph предполагает сборку OpenSceneGraph вне Android Studio с помощью CMake. Такой подход имеет следующие ограничения:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ручная сборка OpenSceneGraph под каждую платформу&lt;/li&gt;
&lt;li&gt;Ручное копирование собранных библиотек OpenSceneGraph в проект Android Studio&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Наш подход включает в себя сборку OpenSceneGraph для тех платформ, для которых собирается проект Android Studio. К тому же, OpenSceneGraph используется как часть проекта, поэтому нет никакой дополнительной рутины: достаточно просто пересобрать проект, и всё готово.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем описание создания самоучителей по сборке приложения OpenSceneGraph на Linux, macOS, Windows и Android в апреле 2017.&lt;/p&gt;</summary></entry><entry><title>It's all fine</title><link href="http://opengamestudio.org/its-all-fine.html" rel="alternate"></link><updated>2017-04-07T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-04-07:its-all-fine.html</id><summary type="html">&lt;p&gt;&lt;img alt="ItsAllFine" src="http://opengamestudio.org/2017-04_its-all-fine.png" /&gt;&lt;/p&gt;
&lt;p&gt;This article describes creation of the first four OpenSceneGraph tutorials in March 2017.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/"&gt;first four OpenSceneGraph tutorials&lt;/a&gt; explain how to create a cube model with Blender and display the model under Linux, macOS, or Windows using OpenSceneGraph tool called osgviewer.&lt;/p&gt;
&lt;p&gt;The whole process of creating a single tutorial turned out to be pretty daunting because it includes several tasks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Record original video depicting one or more steps&lt;/li&gt;
&lt;li&gt;Name the steps as clear as possible&lt;/li&gt;
&lt;li&gt;Select the parts of the video that display the step&lt;/li&gt;
&lt;li&gt;Remove the parts of the video that bare no value, e.g., waiting in the middle of compilation&lt;/li&gt;
&lt;li&gt;Select a single frame to best represent current step, e.g., typing a specific command&lt;/li&gt;
&lt;li&gt;Add a detailed description to article, why current step should have been taken&lt;/li&gt;
&lt;li&gt;Proof-read the article&lt;/li&gt;
&lt;li&gt;Correct typos and video timing&lt;/li&gt;
&lt;li&gt;Review the whole video&lt;/li&gt;
&lt;li&gt;Upload the video to YouTube with timestamps of steps for easier navigation&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Some of those tasks had to be repeated multiple times until the combination of video, text, and article was clear and logical.&lt;/p&gt;
&lt;p&gt;Overall, it took us 30 hours to create the tutorials. The whole process gave us a lot of experience, which will help us in shaping learning materials for our technologies in the future. We don't know how they will look like exactly, but they will definitely be better.&lt;/p&gt;
&lt;p&gt;That's it for describing creation of the first four OpenSceneGraph tutorials in March 2017.&lt;/p&gt;</summary></entry><entry><title>Всё проходит хорошо</title><link href="http://opengamestudio.org/its-all-fine-ru.html" rel="alternate"></link><updated>2017-04-07T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-04-07:its-all-fine-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="ItsAllFine" src="http://opengamestudio.org/2017-04_its-all-fine.png" /&gt;&lt;/p&gt;
&lt;p&gt;Эта статья рассказывает о создании первых четырёх самоучителей OpenSceneGraph в марте 2017.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/"&gt;Первые четыре самоучителя OpenSceneGraph&lt;/a&gt; объясняют, как создать модель куба в Blender и затем отобразить её на Linux, macOS или Windows с помощью osgviewer, стандартного инструмента OpenSceneGraph.&lt;/p&gt;
&lt;p&gt;Процесс создания одного самоучителя оказался довольно утомительным, т.к. он состоит из следующих задач:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Записать видео с одним или более шагами&lt;/li&gt;
&lt;li&gt;Назвать эти шаги как можно яснее&lt;/li&gt;
&lt;li&gt;Выбрать те части видео, которые непосредственно показывают шаг&lt;/li&gt;
&lt;li&gt;Убрать те части видео, которые не имеют значения, например, ожидание сборки&lt;/li&gt;
&lt;li&gt;Выбрать один кадр, лучше всего передающий смысл этого шага, например, набор команды&lt;/li&gt;
&lt;li&gt;Добавить детальное описание в статью, почему этот шаг был необходим&lt;/li&gt;
&lt;li&gt;Перечитать статью&lt;/li&gt;
&lt;li&gt;Поправить опечатки и монтаж видео&lt;/li&gt;
&lt;li&gt;Пересмотреть полное видео&lt;/li&gt;
&lt;li&gt;Загрузить видео на YouTube с временными отметками шагов для упрощения навигации&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Некоторые из этих задач приходилось повторять несколько раз до тех пор, пока комбинация видео, текста и статьи не получилась целостной.&lt;/p&gt;
&lt;p&gt;Всего мы потратили 30 часов на создание самоучителей. В ходе их создания мы почерпнули много нового, что поможет нам улучшить обучающие материалы наших технологий в будущем. Сейчас мы ещё не в курсе, как именно эти материалы будут выглядеть, но они точно будут лучше.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем рассказ о создании первых четырёх самоучителей OpenSceneGraph в марте 2017.&lt;/p&gt;</summary></entry><entry><title>Let's go</title><link href="http://opengamestudio.org/lets-go.html" rel="alternate"></link><updated>2017-03-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-03-16:lets-go.html</id><summary type="html">&lt;p&gt;&lt;img alt="Let's go" src="http://opengamestudio.org/2017-03_lets-go.png" /&gt;&lt;/p&gt;
&lt;p&gt;In this article we describe our progress in January and February of 2017: rendering under iOS/Web and a new tutorial tool.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rendering under iOS/Web&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To our surprise, we got a simple red cube rendered under &lt;a href="https://twitter.com/OpenGameStudio/status/826816343433498627"&gt;iOS&lt;/a&gt; and &lt;a href="https://twitter.com/OpenGameStudio/status/829731986264698881"&gt;Web&lt;/a&gt; pretty fast: in early February. However, this is only the beginning of this year's challenge to support Android, iOS, and Web platforms. There's a long and bumpy road ahead of us as we need a lot more on each platform before we can claim a success: visual effects, Python scripting, data archives.&lt;/p&gt;
&lt;p&gt;Since it took us about four months to get to mobile and web platforms, we decided to share our knowledge and help OpenSceneGraph community with a guide that shows how to use OpenSceneGraph on desktop, mobile, and web. We believe the more widespread OpenSceneGraph is, the stronger our technology becomes. As Isaac Newton said, "If I have seen further, it is by standing on the shoulders of giants." OpenSceneGraph is our giant.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tutorial tool&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Having conducted four live sessions before, it was clear the guide needs videos depicting every nuance. However, bare video alone is only good for showing what to do and not for explaining why do it in a certain way. That's why we decided to combine video with text in the forms of video subtitles and separate articles.&lt;/p&gt;
&lt;p&gt;To combine text and video, we first tried &lt;a href="http://openshotvideo.com"&gt;OpenShot&lt;/a&gt;. It worked well, but we quickly saw its limitations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Too much time is spent on adjusting time frames and animations&lt;/li&gt;
&lt;li&gt;Project file and original resources are hard to track with VCS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since OpenSceneGraph cross-platform guide would consist of several tutorials, we decided to automate the process. Brief research revealed a great multimedia framework called &lt;a href="http://mltframework.org"&gt;MLT&lt;/a&gt;, which powers OpenShot itself. With MLT we got our tutorial tool in no time.&lt;/p&gt;
&lt;p&gt;Currently, the tutorial tool allows anyone to combine text and video using a simple text file like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;background bg.png
text 5 Let&amp;#39;s install Blender
video 0:6 install_blender.mp4
text 5 Installing it with apt
video 6:26 install_blender.mp4
text 5 We&amp;#39;re still installing it
video 26:56 install_blender.mp4
text 5 Congratulations! We just finished installing Blender
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is the actual script. See the final result &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/tree/master/tutorial-tool"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That's it for describing our progress in January and February of 2017: rendering under iOS/Web and the new tutorial tool.&lt;/p&gt;</summary></entry><entry><title>Поехали</title><link href="http://opengamestudio.org/lets-go-ru.html" rel="alternate"></link><updated>2017-03-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-03-16:lets-go-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Let's go" src="http://opengamestudio.org/2017-03_lets-go.png" /&gt;&lt;/p&gt;
&lt;p&gt;В этой статье мы расскажем о результатах нашей работы в январе и феврале 2017: отображении куба на iOS/Веб и нашем инструменте для создания самоучителей.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Отображение куба на iOS/Web&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;К нашему удивлению, мы смогли отобразить простой красный куб на &lt;a href="https://twitter.com/OpenGameStudio/status/826816343433498627"&gt;iOS&lt;/a&gt; и &lt;a href="https://twitter.com/OpenGameStudio/status/829731986264698881"&gt;Веб&lt;/a&gt; довольно быстро: в начале февраля. Тем не менее, это лишь начало поддержки платформ Android, iOS и Веб. Впереди нас ждёт тернистая дорога, т.к. нам предстоит сделать ещё много вещей, прежде чем мы сможем объявить о полноценной поддержке этих платформ: визуальные эффекты, скрипты Python, архивы данных.&lt;/p&gt;
&lt;p&gt;Т.к. нам потребовалось четыре месяца для начала поддержки платформ Android, iOS и  Веб, мы решили поделиться своими знаниями и помочь сообществу OpenSceneGraph. Мы напишем руководство по использованию OpenSceneGraph на ПК, мобилках и Вебе. Мы верим: чем более распространён OpenSceneGraph, тем сильнее наши собственные технологии. Как сказал Исаак Ньютон: "Если я видел дальше других, то потому, что стоял на плечах гигантов". OpenSceneGraph - наш гигант.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Инструмент для создания самоучителей&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Имея за плечами опыт проведения четырёх прямых эфиров, нам стало ясно, что руководство по использованию OpenSceneGraph будет полезно лишь при наличии видео. Но голое видео способно отразить лишь то, что мы делаем, но не то, почему мы делаем именно это и именно так. Поэтому мы решили совместить видео с текстом в форме как субтитров к видео, так и отдельных статей.&lt;/p&gt;
&lt;p&gt;Первую попытку совмещения видео с текстом мы начали с помощью &lt;a href="http://openshotvideo.com"&gt;OpenShot&lt;/a&gt;. Инструмент хороший, но с первого же дня использования стали очевидны следующие ограничения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Настройка моментов отображения текста и анимаций занимает много времени&lt;/li&gt;
&lt;li&gt;Файл проекта и исходные ресурсы сложно положить в систему контроля версий&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Т.к. руководство по использованию OpenSceneGraph будет состоять из нескольких самоучителей, мы решили автоматизировать процесс. Быстрый поиск рассказал нам о существовании замечательного мультимедийного фреймворка &lt;a href="http://mltframework.org"&gt;MLT&lt;/a&gt;, который используется и в OpenShot. С помощью MLT мы быстро сделали свой инструмент для создания самоучителей.&lt;/p&gt;
&lt;p&gt;На текущий момент наш инструмент позволяет совместить видео и текст с помощью простого текстового файла:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;background bg.png
text 5 Let&amp;#39;s install Blender
video 0:6 install_blender.mp4
text 5 Installing it with apt
video 6:26 install_blender.mp4
text 5 We&amp;#39;re still installing it
video 26:56 install_blender.mp4
text 5 Congratulations! We just finished installing Blender
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Это реальный скрипт. Конечный результат можно увидеть &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/tree/master/tutorial-tool"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем рассказ о результатах нашей работы в январе и феврале 2017: отображении куба на iOS/Веб и нашем инструменте для создания самоучителей.&lt;/p&gt;</summary></entry><entry><title>The year of challenges</title><link href="http://opengamestudio.org/the-year-of-challenges.html" rel="alternate"></link><updated>2017-01-25T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-01-25:the-year-of-challenges.html</id><summary type="html">&lt;p&gt;&lt;img alt="The year of challenges" src="http://opengamestudio.org/2017-01_the-year-of-challenges.png" /&gt;&lt;/p&gt;
&lt;p&gt;This article describes our plans for 2017.&lt;/p&gt;
&lt;p&gt;Our past plans suggested we would have Android platform support by this time. However, we have a long way to go, before we can declare Android support. See for yourself:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Android rendering" src="http://opengamestudio.org/2017-01_mjin-android-gles.png" /&gt;&lt;/p&gt;
&lt;p&gt;Some people would consider this a failure. We don't. We see a chance to start low and jump high!&lt;/p&gt;
&lt;p&gt;Having only worked with liberal and forgiving desktop environments, Android was a complete surprise for us. Android punished us for everything: memory, resources, graphics. The usual Android response was either a crash, or an empty screen.
At the same time, such a harsh environment highlighted weak spots in our technologies and helped us see where to go next.&lt;/p&gt;
&lt;p&gt;This month we start working on iOS platform support, even though we have only scratched Android. Why? Because it's a lot easier to get those red cubes rendered on iOS without polishing Android first. We don't want to spend months polishing Android only to find out later we had to implement certain feature differently so that it works on all supported platforms.&lt;/p&gt;
&lt;p&gt;And right after we get those cubes rendered on iOS, we start to work on bringing them to Web.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;You got it right: we challenge ourselves with support for Android, iOS, and Web this year.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;That's it for describing our plans for 2017.&lt;/p&gt;</summary></entry><entry><title>Год испытаний</title><link href="http://opengamestudio.org/the-year-of-challenges-ru.html" rel="alternate"></link><updated>2017-01-25T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2017-01-25:the-year-of-challenges-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="The year of challenges" src="http://opengamestudio.org/2017-01_the-year-of-challenges.png" /&gt;&lt;/p&gt;
&lt;p&gt;Эта статья содержит наши планы на 2017 год.&lt;/p&gt;
&lt;p&gt;Наши предыдущие планы предполагали, что сейчас у нас уже будет поддержка платформы Android. Тем не менее, у нас впереди ещё очень много работы, прежде чем мы сможем объявить о поддержке Android. Судите сами:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Android rendering" src="http://opengamestudio.org/2017-01_mjin-android-gles.png" /&gt;&lt;/p&gt;
&lt;p&gt;Кто-нибудь может посчитать это неудачей. Но не мы. Мы видим шанс начать с низкого старта и прыгнуть высоко!&lt;/p&gt;
&lt;p&gt;Т.к. ранее мы имели опыт работы лишь с либеральным и всё прощающим настольным ПК, Android стал для нас полной неожиданностью. На каждом шагу нас ожидало наказание за фривольное использование памяти, ресурсов, графики. Чаще всего в ответ на наши действия мы получали либо падение приложения, либо пустой экран.
С другой стороны, такие суровые условия высветили слабые места в наших технологиях и помогли увидеть, куда нам двигаться дальше.&lt;/p&gt;
&lt;p&gt;В этом месяце мы начинаем работу над поддержкой платформы iOS, хотя мы лишь слегка коснулись платформы Android. Почему? Потому что намного проще отобразить эти красные кубы на iOS без предварительной полировки Android. Мы не хотим потратить месяцы на полировку Android лишь для того, чтобы позже узнать о том, что какой-либо функционал следовало делать иначе для его работы на всех поддерживаемых платформах.&lt;/p&gt;
&lt;p&gt;Сразу после отображения этих кубов на iOS мы начнём работу над их отображением в Вебе.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Всё верно: нашей целью в этом году является поддержка платформ Android, iOS и Веб.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем описание наших планов на 2017 год.&lt;/p&gt;</summary></entry><entry><title>Happy 2017</title><link href="http://opengamestudio.org/2017-happy-new-year.html" rel="alternate"></link><updated>2016-12-31T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2016-12-31:2017-happy-new-year.html</id><summary type="html">&lt;p&gt;&lt;img alt="Happy new year" src="http://opengamestudio.org/2016-12-31_happy-new-year.png" /&gt;&lt;/p&gt;
&lt;p&gt;Okay. It's been a hard year for everyone in the team. And it's almost over. Praise it ends! Praise the new one!&lt;/p&gt;
&lt;p&gt;It may seem, that our progress stalled. Three years ago we announced the beginning of a new project (two to be precise), and now we still working on the engine and editor, haven't even started creating the actual game.&lt;/p&gt;
&lt;p&gt;If you were monitoring our news during the year, you know that we held several live sessions, showing in the real time how to use our tools to create some simple games. Each session was a step in a long road to our goal. While preparing for these live sessions, we added necessary building blocks, that will be needed to create almost any game.&lt;/p&gt;
&lt;p&gt;Future live sessions and technical previews will add even more, so at some point in future (i hope not very distant), we will have everything we need to sit down and build our planned game from these blocks.&lt;/p&gt;
&lt;p&gt;So, the project isn't dead; the idea was not thrown away. But there is a lot of work to be done before we can start making the game, and there are only two of us, using our spare time.
So. You want our game to become a reality? Join us. Together we will rule the galaxy. Or just wait and see. We didn't stop several years ago. We won't stop now.
After all, there is only one way to create a fine tool (and it's our initial goal if you remember) - we need to use it ourselves.
We will. Stay tuned.&lt;/p&gt;
&lt;p&gt;Happy 2017. Let it be simple.&lt;/p&gt;</summary></entry><entry><title>Счастливого 2017-го</title><link href="http://opengamestudio.org/2017-happy-new-year-ru.html" rel="alternate"></link><updated>2016-12-31T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2016-12-31:2017-happy-new-year-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Happy new year" src="http://opengamestudio.org/2016-12-31_happy-new-year.png" /&gt;&lt;/p&gt;
&lt;p&gt;Ну вот. Это был тяжелый год для всех в команде. И он почти закончен. Хвала окончанию старого! Хвала наступлению нового!&lt;/p&gt;
&lt;p&gt;Может показаться, что наш прогресс застопорился. Три года назад мы объявили о начале нового проекта (двух, если быть точным), но до сих пор мы работаем над движком и редактором, даже не начали делать ни Shuan, ни Mahjong 2.&lt;/p&gt;
&lt;p&gt;Если вы следили за новостями в течение года, вы знаете что мы провели несколько "живых сессий", демонстрируя в реальном времени как можно использовать наш инструментарий для создания простой игры. Каждая сессия была шагом в долгом пути к нашей цели. В процессе подготовки к ним, мы добавляли важные элементы, которые будут необходимы для создания любой игры.&lt;/p&gt;
&lt;p&gt;Будущие сессии и демонстрации добавят даже больше, так что в будущем (надеюсь не слишком отдаленном), у нас будет все необходимое для того чтобы просто сесть и собрать планируемую игру из этих элементов.&lt;/p&gt;
&lt;p&gt;Так что проект не умер; идея не отброшена. Очень много работы предстоит сделать, прежде чем мы можем начать делать игру. И нас только двое, занимающихся всем этим в свое свободное время.
Итак, вы хотите, чтобы наша игра стала реальностью? Присоединяйтесь к нам. Вместе мы будем править галактикой. Или можете просто подождать. Мы не бросили все это несколько лет назад. Не станем и сейчас.
В конце концов, есть только один способ создать годный инструмент (а это наша первоначальная цель, если вы помните) - мы должны использовать его сами.
Мы будем. Следите за новостями.&lt;/p&gt;
&lt;p&gt;Счастливого 2017-го. Пусть он будет простым.&lt;/p&gt;</summary></entry><entry><title>November 2016 recap</title><link href="http://opengamestudio.org/2016-november-recap.html" rel="alternate"></link><updated>2016-12-15T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2016-12-15:2016-november-recap.html</id><summary type="html">&lt;p&gt;&lt;img alt="November recap" src="http://opengamestudio.org/2016-12-15_2016-november-recap.png" /&gt;&lt;/p&gt;
&lt;p&gt;This article describes the start of MJIN library separation into modules.&lt;/p&gt;
&lt;p&gt;Once we built OpenSceneGraph for Android, it became obvious that some MJIN functionality is not suitable for Android. For example, UIQt provides a basis for OGS Editor UI. Since OGS Editor is a desktop application, we don't need UIQt for Android.&lt;/p&gt;
&lt;p&gt;We decided to have a look at two approaches to separate MJIN into modules: build-time separation and run-time one. 
&lt;strong&gt;Build-time&lt;/strong&gt; separation means MJIN becomes highly configurable and each platform gets specifically tailored MJIN build.
&lt;strong&gt;Run-time&lt;/strong&gt; separation means MJIN is divided into smaller libraries that are connected at run-time, which makes it easy to change functionality without rebuilding.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Run-time separation research.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Since run-time separation has more benefits, we started researching it first.
The easiest way to achieve it was to use C API, because C ABI rules are much simpler than C++ one's.&lt;/p&gt;
&lt;p&gt;We created a sample project consisting of the application, library, and plugin.
&lt;strong&gt;The application&lt;/strong&gt; has been linked to the library and used it to load the plugin.
&lt;strong&gt;The library&lt;/strong&gt; provided functions to register plugins and call their functions.
&lt;strong&gt;The plugin&lt;/strong&gt; provided functions for the library and called library functions.&lt;/p&gt;
&lt;p&gt;The research was successful: the sample project worked correctly under Linux and Windows. However, since MJIN is currently a single large entity, we postponed C API application until we finish build-time separation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Build-time separation start.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We extracted the following modules from MJIN:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Android: provides Java Native Interface (JNI) to MJIN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sound: provides access to OpenAL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UIQt: provides access to Qt UI&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sound and UIQt modules are currently statically linked into MJIN library, while Android module is already a separate library due to JNI requirements.&lt;/p&gt;
&lt;p&gt;In the coming year, we're going to significantly restructure MJIN so that it suits as many platforms as possible.&lt;/p&gt;
&lt;p&gt;That's it for describing the start of MJIN library separation into modules.&lt;/p&gt;</summary></entry><entry><title>Ноябрь 2016 кратко</title><link href="http://opengamestudio.org/2016-november-recap-ru.html" rel="alternate"></link><updated>2016-12-15T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2016-12-15:2016-november-recap-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="November recap" src="http://opengamestudio.org/2016-12-15_2016-november-recap.png" /&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает начало разделения библиотеки MJIN на модули.&lt;/p&gt;
&lt;p&gt;Как только мы собрали OpenSceneGraph для Android, стало очевидно, что часть функционала MJIN не нужна на Android. Например, UIQt - это основа интерфейса Редактора. Раз Редактор - это приложение для ПК, то UIQt не нужен на Android.&lt;/p&gt;
&lt;p&gt;Мы решили рассмотреть два подхода к разделению MJIN на модули: во время сборки (build-time) и исполнения (run-time).
Разделение &lt;strong&gt;во время сборки&lt;/strong&gt; означает гибкую систему настроек MJIN, что позволит собирать её различно под каждую платформу.
Разделение &lt;strong&gt;во время исполнения&lt;/strong&gt; означает разделение MJIN на несколько небольших библиотек с последующим соединением во время исполнения, что позволит легко менять функционал без повторной сборки.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Исследование разделения во время исполнения.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Т.к. разделение во время исполнения имеет больше преимуществ, мы начали с этого подхода.
Самый простой способ достичь его заключался в использовании C API, т.к. правила C ABI намного проще правил C++ ABI.&lt;/p&gt;
&lt;p&gt;Мы создали маленький проект, включающий в себя приложение, библиотеку и плагин.
&lt;strong&gt;Приложение&lt;/strong&gt; было слинковано с библиотекой и использовало её для загрузки плагина.
&lt;strong&gt;Библиотека&lt;/strong&gt; предоставляла функции для регистрации плагина и вызывала его функции.
&lt;strong&gt;Плагин&lt;/strong&gt; предоставлял функции для библиотеки и вызывал её функции.&lt;/p&gt;
&lt;p&gt;Исследование прошло на ура: проект работал в полном соответствии с нашими ожиданиями на Linux и Windows.
Тем не менее, т.к. MJIN на текущий момент является большой монолитной сущностью, мы отложили применение C API до окончания разделения во время сборки.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Начало разделения во время сборки.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Мы выделили следующие модули из MJIN:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Android: предоставляет Java Native Interface (JNI) к MJIN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sound: предоставляет доступ к OpenAL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UIQt: предоставляет доступ к Qt&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Модули Sound и UIQt на текущий момент статически линкуются в MJIN, тогда как модуль Android линкуется динамически из-за ограничений JNI.&lt;/p&gt;
&lt;p&gt;В следующем году мы изменим структуру MJIN так, чтобы её можно было легче собрать под разные платформы.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем статью о начале разделения библиотеки MJIN на модули.&lt;/p&gt;</summary></entry><entry><title>October 2016 recap</title><link href="http://opengamestudio.org/2016-october-recap.html" rel="alternate"></link><updated>2016-11-19T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2016-11-19:2016-october-recap.html</id><summary type="html">&lt;p&gt;&lt;img alt="October recap" src="http://opengamestudio.org/2016-11-19_2016-october-recap.png" /&gt;&lt;/p&gt;
&lt;p&gt;This article describes how we spent a month building OpenSceneGraph (OSG) for Android: the first attempt to build OSG, the search for OSG alternatives, and the success in building OSG.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First attempt to build OSG.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Having no prior knowledge of Android development, we grabbed the latest Android Studio and started doing beginner tutorials.
We passed Java part pretty fast. Everything worked out of the box. Then came C++ part and related problems.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMake. &lt;/strong&gt;To work with C++, Android Studio uses custom CMake, which conflicts with the system one. This was a clear indication that we had to set up a separate development environment specifically for Android.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KVM. &lt;/strong&gt;We got Ubuntu under VirtualBox installed. All went fine until we tried to use Android Emulator. Turned out, VirtualBox could not run Android Emulator, because a virtual machine cannot provide kernel virtualization inside already virtualized environment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chroot for Android. &lt;/strong&gt;Since we had a successful experience with chroot to build OGS Editor before, we decided to place Android development environment into chroot. With minor tweaking, we could finally run Android Emulator and build C++ project.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSG. &lt;/strong&gt;Building OSG seemed like a piece of cake at the time. However, all we got was a crash. Thinking that we got it wrong the first time, we tried to rebuild OSG once again. And the same crash again.
Searching for the problem did not reveal any hint.
Nobody helped us at the OSG mailing list.&lt;/p&gt;
&lt;p&gt;We were in despair.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The search for OSG alternatives.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Since OSG community did not help us, we decided to search for an alternative open source project to fit our Android needs (and may be more).&lt;/p&gt;
&lt;p&gt;And we found it: &lt;a href="http://babylonhx.gamestudiohx.com/"&gt;BabylonHX&lt;/a&gt;. The home page looked awesome: it rendered WebGL in the background!
We thought we finally found the gem we were looking for. However, the example on the home page simply did not work.&lt;/p&gt;
&lt;p&gt;You can probably understand our feelings at the time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The success in building OSG.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We realized nobody would make OSG work under Android for us. We had to do it ourselves.&lt;/p&gt;
&lt;p&gt;Since &lt;a href="http://www.openscenegraph.org/index.php/documentation/platform-specifics/android/178-building-openscenegraph-for-android-3-4"&gt;OSG 3.4 document&lt;/a&gt; on building for Android was very short, we no longer trusted it and headed to &lt;a href="http://www.openscenegraph.org/index.php/documentation/platform-specifics/android/44-building-openscenegraph-for-android-3-0-3-0-1"&gt;original OSG 3.0 document&lt;/a&gt;.
While following it, we faced a dead link to third party dependencies.
The search for an alternative download link lead us to a &lt;a href="https://xinyustudio.wordpress.com/2013/09/24/install-osg-for-android-on-ubuntu-13-04-step-by-step-tutorials/"&gt;2013 tutorial&lt;/a&gt; on building OSG 3.0 for Android.&lt;/p&gt;
&lt;p&gt;After following the tutorial, we finally got OSG to run under Android!
But there was a nuance: both OSG and Android tools used in the tutorial were ancient.
In a few days, we gradually updated both OSG and Android tools to their latest versions.&lt;/p&gt;
&lt;p&gt;During the update process, we learned two things that prevented us from having OSG to work in the first place:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android API headers changed in NDK r12&lt;/li&gt;
&lt;li&gt;OSG only works as a static library under Android&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That's it for describing how we spent the month building OSG for Android: the first attempt to build OSG, the search for OSG alternatives, and the success in building OSG.&lt;/p&gt;</summary></entry><entry><title>Октябрь 2016 кратко</title><link href="http://opengamestudio.org/2016-october-recap-ru.html" rel="alternate"></link><updated>2016-11-19T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2016-11-19:2016-october-recap-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="October recap" src="http://opengamestudio.org/2016-11-19_2016-october-recap.png" /&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает, как мы потратили месяц на сборку OpenSceneGraph (OSG) под Android: первая попытка собрать OSG, поиск альтернатив OSG и успех в сборке OSG.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Первая попытка собрать OSG.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Не имея опыта разработки под Android, мы взяли последнюю версию Android Studio и начали проходить самоучители для начинающих.
Java далась легко. Всё работало из коробки. Затем наступил черёд C++ и проблем.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMake. &lt;/strong&gt;Android Studio для работы с C++ использует собственную версию CMake, которая конфликтует с системной. Для нас это было явным сигналом о необходимости подготовить отдельное окружение разработки специально под Android.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KVM. &lt;/strong&gt;Мы установили Ubuntu на VirtualBox. Всё шло замечательно до того момента, пока мы не запустили эмулятор Android. Оказалось, что VirtualBox не может запустить эмулятор, т.к. виртуальная машина не предоставляет виртуализацию внутри уже виртуализированного окружения.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chroot для Android. &lt;/strong&gt;Вспомнив о положительном опыте работы с chroot для сборки OGS Editor, мы решили поместить окружение разработки Android в chroot. После небольших настроек мы сумели запустить эмулятор Android и собрать проект C++.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSG. &lt;/strong&gt;К этому моменту мы считали, что собрать OSG не составит труда, но не тут-то было. Всё, что мы получили, - это падение.
Предположив, что мы ошиблись где-то при первой сборке, мы решили пересобрать OSG ещё раз. И снова получили ту же ошибку.
Поиск решения проблемы не дал результатов.
Никто не помог нам в списке рассылок OSG.&lt;/p&gt;
&lt;p&gt;Мы были в отчаянии.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Поиск альтернатив OSG.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Раз сообщество OSG нам не помогло, мы решили поискать альтернативный открытый проект, который мог решить наши задачи на Android (и, возможно, на других платформах).&lt;/p&gt;
&lt;p&gt;Такой проект мы нашли: &lt;a href="http://babylonhx.gamestudiohx.com/"&gt;BabylonHX&lt;/a&gt;. Домашняя страница выглядела замечательно: она отображала WebGL в фоне!
Промелькнула мысль, что мы наконец нашли алмаз. К сожалению, пример на домашней странице просто не работал.&lt;/p&gt;
&lt;p&gt;Думаем, вы понимаете наши чувства на тот момент.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Успех в сборке OSG.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Мы осознали, что никто за нас не запустит OSG на Android. Нужно было сделать это самостоятельно.&lt;/p&gt;
&lt;p&gt;Потеряв доверие к очень короткой &lt;a href="http://www.openscenegraph.org/index.php/documentation/platform-specifics/android/178-building-openscenegraph-for-android-3-4"&gt;документации OSG 3.4&lt;/a&gt; по сборке для Android, мы решили использовать &lt;a href="http://www.openscenegraph.org/index.php/documentation/platform-specifics/android/44-building-openscenegraph-for-android-3-0-3-0-1"&gt;первоначальную документацию OSG 3.0&lt;/a&gt;.
В ходе следования ей мы наткнулись на мёртвую ссылку, которая должна была содержать зависимости.
Поиск альтернативной ссылки вывел нас на &lt;a href="https://xinyustudio.wordpress.com/2013/09/24/install-osg-for-android-on-ubuntu-13-04-step-by-step-tutorials/"&gt;самоучитель 2013 года&lt;/a&gt; по сборке OSG 3.0 для Android.&lt;/p&gt;
&lt;p&gt;После прохождения самоучителя мы наконец смогли запустить OSG под Android!
Тем не менее, был нюанс: используемые в самоучителе версии OSG и средств разработки Android были древними.
В течение нескольких дней мы постепенно довели версии OSG и средств разработки Android до последних.&lt;/p&gt;
&lt;p&gt;В ходе этого обновления мы узнали о двух вещах, помешавших нам запустить OSG с первого раза:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Изменение заголовков Android API в NDK r12&lt;/li&gt;
&lt;li&gt;OSG работает под Android лишь в виде статической библиотеки&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На этом мы заканчиваем описание того, как мы потратили месяц на сборку OSG под Android: первая попытка собрать OSG, поиск альтернатив OSG и успех в сборке OSG.&lt;/p&gt;</summary></entry><entry><title>Technology showcases</title><link href="http://opengamestudio.org/2016-tech-showcases.html" rel="alternate"></link><updated>2016-10-31T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2016-10-31:2016-tech-showcases.html</id><summary type="html">&lt;p&gt;&lt;img alt="TechShowcases" src="http://opengamestudio.org/2016-10-31_tech-showcases.png" /&gt;&lt;/p&gt;
&lt;p&gt;In this article, we take another look at 2015-2016 live sessions' format and introduce a new showcase format for 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2015 and 2016: live sessions.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As you know, we use live sessions to show the state of our technology and create a small functional game from scratch.
We have conducted four live sessions in the past year, which gave birth to the following small games:
&lt;table&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;strong&gt;№&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Created game&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Live session date&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;Whac-a-mole&lt;/td&gt;
  &lt;td&gt;November 2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;td&gt;Rolling ball&lt;/td&gt;
  &lt;td&gt;February 2016&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;Domino&lt;/td&gt;
  &lt;td&gt;May 2016&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;Mahjong Solitaire&lt;/td&gt;
  &lt;td&gt;September 2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;We spent four months to prepare for these live sessions.
It has been an extremely useful experience for us. However, 2017 will have only 2 live sessions.
Why? We want to spend more time on actual development!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017: live sessions + technical previews.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Starting next year, we will be doing technical previews twice a year. A technical preview is another way to show the state of our technology, but without creating new games and conducting live sessions.&lt;/p&gt;
&lt;p&gt;Here's an approximate schedule of technical previews and live sessions for 2017:
&lt;table&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;strong&gt;№&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Month&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Showcase type&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Topic&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;January&lt;/td&gt;
  &lt;td&gt;Technical preview&lt;/td&gt;
  &lt;td&gt;Android platform support&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;td&gt;April&lt;/td&gt;
  &lt;td&gt;Live session&lt;/td&gt;
  &lt;td&gt;Android game creation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;July&lt;/td&gt;
  &lt;td&gt;Technical preview&lt;/td&gt;
  &lt;td&gt;To be announced&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;October&lt;/td&gt;
  &lt;td&gt;Live session&lt;/td&gt;
  &lt;td&gt;To be announced&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;That's it for taking another look at 2015-2016 live sessions' format and introducing the new showcase format for 2017.&lt;/p&gt;</summary></entry><entry><title>Демонстрации технологий</title><link href="http://opengamestudio.org/2016-tech-showcases-ru.html" rel="alternate"></link><updated>2016-10-31T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:opengamestudio.org,2016-10-31:2016-tech-showcases-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="TechShowcases" src="http://opengamestudio.org/2016-10-31_tech-showcases.png" /&gt;&lt;/p&gt;
&lt;p&gt;Сегодня мы ещё раз взглянем на формат демонстраций в 2015-2016 годах, а также сообщим о новом формате 2017-го.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2015 и 2016: демонстрации в прямом эфире.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Как вы знаете, в ходе демонстраций мы в прямом эфире показываем состояние наших технологий и собираем небольшую работающую игру с нуля.
За прошедший год мы провели 4 демонстрации в прямом эфире, в ходе которых создали следующие небольшие игры:
&lt;table&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;strong&gt;№&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Созданная игра&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Дата демонстрации в прямом эфире&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;Поймай крота&lt;/td&gt;
  &lt;td&gt;Ноябрь 2015&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;td&gt;Катящийся мяч&lt;/td&gt;
  &lt;td&gt;Февраль 2016&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;Домино&lt;/td&gt;
  &lt;td&gt;Май 2016&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;Пасьянс Маджонг&lt;/td&gt;
  &lt;td&gt;Сентябрь 2016&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;На подготовку ко всем 4-м демонстрациям у нас ушло 4 месяца.
Это был очень полезный для нас опыт. Тем не менее, в 2017-м году мы ограничимся лишь двумя такими демонстрациями.
Почему? Потому что мы будем тратить больше времени непосредственно на разработку!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2017: демонстрации в прямом эфире + технические анонсы.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Место двух демонстраций займут технические анонсы. Технический анонс - это тоже демонстрация прогресса наших технологий, но без создания игр в прямом эфире.&lt;/p&gt;
&lt;p&gt;Примерный календарь технических анонсов и демонстраций на 2017-й год выглядит следующим образом:
&lt;table&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;strong&gt;№&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Месяц&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Вид демонстрации&lt;/strong&gt;&lt;/th&gt;
  &lt;th&gt;&lt;strong&gt;Тема&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;1&lt;/td&gt;
  &lt;td&gt;Январь&lt;/td&gt;
  &lt;td&gt;Технический анонс&lt;/td&gt;
  &lt;td&gt;Поддержка платформы Android&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;2&lt;/td&gt;
  &lt;td&gt;Апрель&lt;/td&gt;
  &lt;td&gt;Демонстрация в прямом эфире&lt;/td&gt;
  &lt;td&gt;Создание игры для Android&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td&gt;Июль&lt;/td&gt;
  &lt;td&gt;Технический анонс&lt;/td&gt;
  &lt;td&gt;Будет объявлено позднее&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;4&lt;/td&gt;
  &lt;td&gt;Октябрь&lt;/td&gt;
  &lt;td&gt;Демонстрация в прямом эфире&lt;/td&gt;
  &lt;td&gt;Будет объявлено позднее&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем рассказ о формате демонстраций в 2015-2016 годах, а также о новом формате 2017-го.&lt;/p&gt;</summary></entry></feed>