<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Opensource Game Studio</title><link href="https://kaisd.github.io/ogs-site/" rel="alternate"></link><link href="https://kaisd.github.io/ogs-site/feeds/all.atom.xml" rel="self"></link><id>https://kaisd.github.io/ogs-site/</id><updated>2017-10-16T00:00:00+03:00</updated><entry><title>Back to the Static</title><link href="https://kaisd.github.io/ogs-site/back-to-the-static.html" rel="alternate"></link><published>2017-10-16T00:00:00+03:00</published><updated>2017-10-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-10-16:/ogs-site/back-to-the-static.html</id><summary type="html">&lt;p&gt;&lt;img alt="Back to the Static" src="https://kaisd.github.io/ogs-site/2017-10-16-back-to-the-static.png"&gt;&lt;/p&gt;
&lt;p&gt;We have been using Wordpress as our website engine for more than seven years. And now it's time to move forward. Or backward.
For some time we've been tracking the development of the new breed of website engines - static site generators.
It seems that this is the technology capable of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Back to the Static" src="https://kaisd.github.io/ogs-site/2017-10-16-back-to-the-static.png"&gt;&lt;/p&gt;
&lt;p&gt;We have been using Wordpress as our website engine for more than seven years. And now it's time to move forward. Or backward.
For some time we've been tracking the development of the new breed of website engines - static site generators.
It seems that this is the technology capable of changing past into future.&lt;/p&gt;
&lt;p&gt;A static website is more straightforward, quicker and more secure. And with the help of generators, it is also as easy to manage, as the dynamic website.
So, we are starting our site anew with the help of the &lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;.
Right now it doesn't have all the content from our old site, but we'll add most of it soon.&lt;/p&gt;</content></entry><entry><title>Назад в Статику</title><link href="https://kaisd.github.io/ogs-site/back-to-the-static-ru.html" rel="alternate"></link><published>2017-10-16T00:00:00+03:00</published><updated>2017-10-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-10-16:/ogs-site/back-to-the-static-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Назад в Статику" src="https://kaisd.github.io/ogs-site/2017-10-16-back-to-the-static.png"&gt;&lt;/p&gt;
&lt;p&gt;Мы используем Wordpress в качестве движка нашего сайта уже более семи лет. И теперь пришло время двигаться вперед. Или назад.
Некоторое время мы следили за разработкой нового поколения движков - генераторов статических сайтов.
Похоже, что это технология, способная превратить прошлое в будущее.&lt;/p&gt;
&lt;p&gt;Статический веб-сайт проще, быстрее и безопаснее. И с помощью …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Назад в Статику" src="https://kaisd.github.io/ogs-site/2017-10-16-back-to-the-static.png"&gt;&lt;/p&gt;
&lt;p&gt;Мы используем Wordpress в качестве движка нашего сайта уже более семи лет. И теперь пришло время двигаться вперед. Или назад.
Некоторое время мы следили за разработкой нового поколения движков - генераторов статических сайтов.
Похоже, что это технология, способная превратить прошлое в будущее.&lt;/p&gt;
&lt;p&gt;Статический веб-сайт проще, быстрее и безопаснее. И с помощью генераторов им настолько же легко управлять, как и динамическим веб-сайтом.
Так что мы начинаем наш сайт заново с помощью [Pelican] (https://blog.getpelican.com/).
Сейчас здесь нет всего контента с нашего старого сайта, но мы добавим его в ближайшее время.&lt;/p&gt;</content></entry><entry><title>The birth of MJIN world</title><link href="https://kaisd.github.io/ogs-site/mjin-world-birth.html" rel="alternate"></link><published>2017-09-10T00:00:00+03:00</published><updated>2017-09-10T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-09-10:/ogs-site/mjin-world-birth.html</id><summary type="html">&lt;p&gt;&lt;img alt="The birth of MJIN world" src="https://kaisd.github.io/ogs-site/2017-09-mjin-world-birth.png"&gt;&lt;/p&gt;
&lt;p&gt;This article describes the birth of MJIN world in August 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-player&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As you know, &lt;a href="https://kaisd.github.io/ogs-site/scripting-research.html"&gt;we spent July to research scripting&lt;/a&gt;. We found a solution that satisfies the following criteria. Scripts should:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;run unchanged on all supported platforms&lt;/li&gt;
&lt;li&gt;allow extending C++ code&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have verified the second criterion by writing …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="The birth of MJIN world" src="https://kaisd.github.io/ogs-site/2017-09-mjin-world-birth.png"&gt;&lt;/p&gt;
&lt;p&gt;This article describes the birth of MJIN world in August 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-player&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As you know, &lt;a href="https://kaisd.github.io/ogs-site/scripting-research.html"&gt;we spent July to research scripting&lt;/a&gt;. We found a solution that satisfies the following criteria. Scripts should:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;run unchanged on all supported platforms&lt;/li&gt;
&lt;li&gt;allow extending C++ code&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have verified the second criterion by writing a sample application. The first criterion was taken for granted because it SHOULD be true.&lt;/p&gt;
&lt;p&gt;At the time, we saw two ways to verify the first criterion:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;create one sample application for each platform to verify scripting only&lt;/li&gt;
&lt;li&gt;create a single cross-platform application, which can run any code&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We chose the second approach because it is more beneficial in the long run. As you might have guessed, &lt;a href="https://bitbucket.org/ogstudio/mjin-player"&gt;mjin-player&lt;/a&gt; is that application.&lt;/p&gt;
&lt;p&gt;mjin-player serves as a base for the rest of MJIN projects to make them run on all supported platforms. However, there's no magic trick to hide the projects from the platform, and there was no such intention. Instead, mjin-player provides a consistent set of rules how other MJIN projects should be structured to be able to run on all supported platforms.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-application&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This set of rules for MJIN projects is packaged into &lt;a href="https://bitbucket.org/ogstudio/mjin-application"&gt;mjin-application&lt;/a&gt;. mjin-application is a library that provides basic functionality every MJIN project would need and nothing more. For instance, mjin-application does not and will not contain scripting or any other specific functionality.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MJIN world&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So what is &lt;a href="https://bitbucket.org/ogstudio/mjin"&gt;MJIN world&lt;/a&gt;? It's a set of projects that constitute our game development tools. mjin-player and mjin-application are the first bricks of the newly born MJIN world. A lot more to come. Stay tuned for the brighter MJIN future.&lt;/p&gt;
&lt;p&gt;That's it for describing the birth of MJIN world in August 2017.&lt;/p&gt;</content></entry><entry><title>Рождение вселенной MJIN</title><link href="https://kaisd.github.io/ogs-site/mjin-world-birth-ru.html" rel="alternate"></link><published>2017-09-10T00:00:00+03:00</published><updated>2017-09-10T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-09-10:/ogs-site/mjin-world-birth-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Рождение вселенной MJIN" src="https://kaisd.github.io/ogs-site/2017-09-mjin-world-birth.png"&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает рождение вселенной MJIN в августе 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-player&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Как вы знаете, &lt;a href="https://kaisd.github.io/ogs-site/scripting-research-ru.html"&gt;в июле мы изучали скриптование&lt;/a&gt;. Мы нашли решение, которое удовлетворяет следующим критериям. Скрипты должны:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;исполняться в исходном виде без изменений на всех поддерживаемых платформах&lt;/li&gt;
&lt;li&gt;позволять расширять код C++&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Мы проверили второй критерий в рамках тестового приложения. В …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Рождение вселенной MJIN" src="https://kaisd.github.io/ogs-site/2017-09-mjin-world-birth.png"&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает рождение вселенной MJIN в августе 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-player&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Как вы знаете, &lt;a href="https://kaisd.github.io/ogs-site/scripting-research-ru.html"&gt;в июле мы изучали скриптование&lt;/a&gt;. Мы нашли решение, которое удовлетворяет следующим критериям. Скрипты должны:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;исполняться в исходном виде без изменений на всех поддерживаемых платформах&lt;/li&gt;
&lt;li&gt;позволять расширять код C++&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Мы проверили второй критерий в рамках тестового приложения. В первый критерий мы просто поверили, т.к. он ДОЛЖЕН быть верен.&lt;/p&gt;
&lt;p&gt;В тот момент мы видели два варианта проверки первого критерия:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;создать по одному тестовому приложению под каждую платформу для проверки лишь этого критерия&lt;/li&gt;
&lt;li&gt;создать одно кросс-платформенное приложение, которому можно скормить практически любой код&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Мы выбрали второй подход, т.к. он выгоднее в долгосрочной перспективе. Как вы уже догадались, &lt;a href="https://bitbucket.org/ogstudio/mjin-player"&gt;mjin-player&lt;/a&gt; является тем самым кросс-платформенным приложением.&lt;/p&gt;
&lt;p&gt;mjin-player служит базой для остальных проектов MJIN, которая позволяет этим проектам работать на всех поддерживаемых платформах. Тем не менее, в mjin-player нет никакой магии, проекты никак не скрыты от деталей платформ, да и не было такой задачи. Вместо скрытия деталей платформы mjin-player предоставляет набор правил, которым должны удовлетворять проекты MJIN для работы на всех поддерживаемых платформах.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mjin-application&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Этот набор правил представлен в виде &lt;a href="https://bitbucket.org/ogstudio/mjin-application"&gt;mjin-application&lt;/a&gt;. mjin-application является библиотекой с базовым функционалом, необходимым для каждого проекта MJIN, но не более. Например, mjin-application не содержит и никогда не будет содержать скриптования или подобного специфического функционала.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Вселенная MJIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Так что же такое &lt;a href="https://bitbucket.org/ogstudio/mjin"&gt;вселенная MJIN&lt;/a&gt;? Это множество проектов, которые являются нашими средствами для разработки игр. mjin-player и mjin-application - первые кирпичики недавно появившейся вселенной MJIN. А будет их намного больше. Оставайтесь на связи, нас ждёт светлое будущее с MJIN.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем описание рождения вселенной MJIN в августе 2017.&lt;/p&gt;</content></entry><entry><title>Scripting research</title><link href="https://kaisd.github.io/ogs-site/scripting-research.html" rel="alternate"></link><published>2017-08-16T00:00:00+03:00</published><updated>2017-08-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-08-16:/ogs-site/scripting-research.html</id><summary type="html">&lt;p&gt;&lt;img alt="Scripting research" src="https://kaisd.github.io/ogs-site/2017-08-scripting-research.png"&gt;&lt;/p&gt;
&lt;p&gt;This article describes scripting research in July 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Our first goal of using a scripting language was to have a platform-independent code that runs unchanged on every supported platform.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OGS Editor 0.10 supports Python for such a code thanks to &lt;a href="http://swig.org/"&gt;SWIG&lt;/a&gt;. SWIG provides a way to wrap almost any …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Scripting research" src="https://kaisd.github.io/ogs-site/2017-08-scripting-research.png"&gt;&lt;/p&gt;
&lt;p&gt;This article describes scripting research in July 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Our first goal of using a scripting language was to have a platform-independent code that runs unchanged on every supported platform.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OGS Editor 0.10 supports Python for such a code thanks to &lt;a href="http://swig.org/"&gt;SWIG&lt;/a&gt;. SWIG provides a way to wrap almost any C/C++ code and use it in dozens of languages like Python, Ruby, Lua, Java, C#, etc.. SWIG really helped us taste the beauty of platform-independent code. However, SWIG only works one way: from C/C++ to a target language. This means the main application must be in the target language, and C/C++ code can only be used as a library.&lt;/p&gt;
&lt;p&gt;Having the main application in Python works fine for the desktop, but not so great for mobile and web, where C and C++ are the only natively supported cross-platform languages. There are projects like &lt;a href="https://kivy.org"&gt;Kivy&lt;/a&gt;, which allow you to develop cross-platform applications in Python, but they are not supported natively. This means it's a lot of headaches when Android and iOS APIs change.&lt;/p&gt;
&lt;p&gt;Having the main application in C/C++ and the need to support scripting means that a scripting language should be interpreted by the application. This is what SWIG, Kivy, and similar projects are not meant to fulfill.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Our secondary goal for using a scripting language was to allow to extend C++ code.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OGS Editor 0.10 has some modules written in C++, and some in Python. The modules are equal from the perspective of the main application; it doesn't care what language the module is written in.&lt;/p&gt;
&lt;p&gt;To achieve such flexibility, we introduced a so-called Environment. Each module would register the keys it responds to, and Environment would deliver corresponding messages. 
Technically such behaviour is achieved by inheriting a base class and overriding its methods in both C++ and a scripting language.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First, we evaluated Python for the role of cross-platform scripting language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Since we already used Python, we started to research the possibility to run Python code on every supported platform. The result was disappointing because CPython (the default Python implementation used on the desktop) does not mention mobile and web platforms. We only found some years old forks of CPython that were claimed to work either on Android or iOS. Such a disarray was not suitable for us.
We also had a look at &lt;a href="http://pypy.org"&gt;PyPy&lt;/a&gt;, another Python implementation. It also did not mention support for mobile and web platforms.&lt;/p&gt;
&lt;p&gt;This was a clear indication that Python community doesn't care for mobile and web platforms. Or that nobody had time to provide the information about building Python on such platforms. Either way, it was not acceptable for us.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Second, we evaluated &lt;a href="http://wren.io"&gt;Wren&lt;/a&gt; for the role of cross-platform scripting language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Wren was the first scripting language we stumbled upon in the long list of non-mainstream scripting languages.&lt;/p&gt;
&lt;p&gt;Wren claimed to be small and easy to learn. Wren also claimed to be intended for embedding in applications. Ironically, the author &lt;a href="http://wren.io/embedding-api.html"&gt;had no time to document how to do the embedding in the first place&lt;/a&gt;. When &lt;a href="https://github.com/munificent/wren/issues/465"&gt;we asked for the time estimates of publishing&lt;/a&gt; the critical part of the documentation, &lt;a href="https://github.com/munificent/wren/issues/402"&gt;we just got a reference to another issue&lt;/a&gt; where the other guy was asking the same question half a year ago!&lt;/p&gt;
&lt;p&gt;That's when we ended our relationship with Wren.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Third, we evaluated &lt;a href="http://chaiscript.com"&gt;Chai&lt;/a&gt; for the role of cross-platform scripting language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Chai was in the long list of non-mainstream scripting languages, too. Chai was promising because it claimed to be specifically tailored for embedding in a C++ application.
We successfully managed to call a C++ function from inside Chai but failed to call a member function. &lt;a href="http://discourse.chaiscript.com/t/cannot-call-a-function-that-accepts-a-string-and-a-vector/334"&gt;We asked for help&lt;/a&gt;, but nobody replied.&lt;/p&gt;
&lt;p&gt;We had to end our relationship with Chai.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fourth, we evaluated Lua for the role of cross-platform scripting language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lua is the mainstream language for embedding. So we decided to try the obvious choice. Documentation looked promising, too. However, by the end of reading the &lt;a href="https://www.lua.org/pil/24.html"&gt;C API&lt;/a&gt; chapter we had no clue how to inherit a class inside Lua.&lt;/p&gt;
&lt;p&gt;This led us to search for libraries that wrap Lua C API syntax into something more meaningful for C++. That's how we found &lt;a href="http://sol2.rtfd.io"&gt;Sol2&lt;/a&gt;. Just as before, the first attempt to call a C++ member function from Lua failed. But unlike before, we asked for help and &lt;a href="https://github.com/ThePhD/sol2/issues/465"&gt;got the help&lt;/a&gt;! This was a refreshing surprise for us.
Next, we tried to inherit a class in Lua and override the class methods. We failed, but &lt;a href="https://github.com/ThePhD/sol2/issues/468"&gt;the author helped us out again&lt;/a&gt;. In the end, we succeeded in inheriting a class and overriding its behaviour.&lt;/p&gt;
&lt;p&gt;That's when we understood it's a start for a long and mutual relationship with Sol2/Lua.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This search for a scripting language taught us one important lesson: people matter, not technologies.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There are lots of scripting languages that look shiny on the outside but are dead. Why? Because some authors don't have time for users. In return, users don't have time for the authors' projects.&lt;/p&gt;
&lt;p&gt;That's it for describing scripting research in July 2017.&lt;/p&gt;</content></entry><entry><title>Изучение скриптования</title><link href="https://kaisd.github.io/ogs-site/scripting-research-ru.html" rel="alternate"></link><published>2017-08-16T00:00:00+03:00</published><updated>2017-08-16T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-08-16:/ogs-site/scripting-research-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Изучение скриптования" src="https://kaisd.github.io/ogs-site/2017-08-scripting-research.png"&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает изучение скриптования в июле 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Наша основная цель использования скриптового языка - это наличие платформо-независимого кода, выполняемого без изменений на каждой поддерживаемой платформе.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Редактор 0.10 использует Python в качестве подобного кода с помощью &lt;a href="http://swig.org/"&gt;SWIG&lt;/a&gt;. SWIG позволяет использовать практически любой код C/C++ из языков вроде Python, Ruby …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Изучение скриптования" src="https://kaisd.github.io/ogs-site/2017-08-scripting-research.png"&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает изучение скриптования в июле 2017.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Наша основная цель использования скриптового языка - это наличие платформо-независимого кода, выполняемого без изменений на каждой поддерживаемой платформе.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Редактор 0.10 использует Python в качестве подобного кода с помощью &lt;a href="http://swig.org/"&gt;SWIG&lt;/a&gt;. SWIG позволяет использовать практически любой код C/C++ из языков вроде Python, Ruby, Lua, Java, C# и т.д.. SWIG помог нам впервые оценить прелесть платформо-независимого кода. К сожалению, SWIG работает лишь в одном направлении: из C/C++ в язык назначения. Это приводит к тому, что основное приложение должно быть написано на языке назначения, а код C/C++ может быть использован лишь в виде библиотеки.&lt;/p&gt;
&lt;p&gt;Основное приложение на языке Python вполне подходит для десктопа, но не для мобилок и веба, где языки C и C++ являются единственными языками, поддерживаемыми нативно на каждой платформе. Конечно, существуют проекты вроде &lt;a href="https://kivy.org"&gt;Kivy&lt;/a&gt;, которые позволяет разрабатывать кросс-платформенные приложения на Python, но они не поддерживаются нативно. Отсутствие нативной поддержки выливается в огромную головную боль при изменении API у Android и iOS.&lt;/p&gt;
&lt;p&gt;Необходимость в приложении на C/C++ и поддержке скриптов приводит к обязательному интерпретированию скриптового языка самим приложением. Это как раз то, что SWIG, Kivy и подобные проекты не позволяют сделать.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Наша вторичная цель использования скриптового языка - это возможность расширения кода C++.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Одни модули Редактора 0.10 написаны на C++, а другие на Python. С точки зрения основного приложения, все модули равны. Для приложения нет никакой разницы, на каком языке написан конкретный модуль.&lt;/p&gt;
&lt;p&gt;Для достижения этой гибкости мы ввели так называемое Окружение (Environment). Каждый модуль регистрирует ключи (keys), на которые он отвечает, а Окружение доставляет соответствующие сообщения. Технически такое поведение можно достигнуть с помощью наследования базового класса и переопределения его методов как в C++, так и в скриптовом языке.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python был первым языком, который мы рассмотрели в качестве платформо-независимого скриптового языка.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Т.к. мы уже использовали Python, то логично было начать изучение с него. Мы хотели проверить, можно ли запустить код Python на каждой поддерживаемой платформе. К сожалению, результаты были удручающими, т.к. документация CPython (реализация Python, используемая по умолчанию на десктопе) никак не упоминала ни мобилки, ни веб. Всё, что мы нашли, - это пара форков CPython лохматых годов, которые якобы работают либо на Android, либо на iOS. Такой раздрай нас не устроил.
Мы также рассмотрели &lt;a href="http://pypy.org"&gt;PyPy&lt;/a&gt;, ещё одну реализацию Python, но она тоже не содержала информации о мобилках и вебе.&lt;/p&gt;
&lt;p&gt;Это было чётким сигналом об отсутствии интереса к мобилками и вебу со стороны сообщества Python. Либо об отсутствии времени даже на то, чтобы описать использование Python на данных платформах. В любом случае, такое положение вещей нас не устроило.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://wren.io"&gt;Wren&lt;/a&gt; был вторым языком, который мы рассмотрели в качестве платформо-независимого скриптового языка.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Wren был первым языком из длинного списка малоизвестных скриптовых языков.&lt;/p&gt;
&lt;p&gt;Wren преподносился как небольшой и простой язык. Согласно документации, основная цель Wren - это быть встроенным в приложение. По иронии судьбы, у автора &lt;a href="http://wren.io/embedding-api.html"&gt;не было времени описать в документации встраивание Wren&lt;/a&gt; в приложение. Когда мы &lt;a href="https://github.com/munificent/wren/issues/465"&gt;спросили о сроках публикации&lt;/a&gt; этой критически важной части документации, мы &lt;a href="https://github.com/munificent/wren/issues/402"&gt;получили в ответ ссылку на тикет&lt;/a&gt;, в котором другой человек спрашивал тот же самый вопрос полгода назад!&lt;/p&gt;
&lt;p&gt;На этом мы закончили отношения с Wren.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://chaiscript.com"&gt;Chai&lt;/a&gt; был третьим языком, который мы рассмотрели в качестве платформо-независимого скриптового языка.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Chai был в том же длинном списке малоизвестных скриптовых языков. Он преподносился как язык, специально предназначенный для встраивания в приложения C++. Мы без проблем вызвали функцию C++ из Chai, но нам не удалось вызвать метод класса. &lt;a href="http://discourse.chaiscript.com/t/cannot-call-a-function-that-accepts-a-string-and-a-vector/334"&gt;Мы попросили о помощи&lt;/a&gt;, но ответом была лишь тишина.&lt;/p&gt;
&lt;p&gt;Нам пришлось завершить отношения с Chai.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua был четвёртым языком, который мы рассмотрели в качестве платформо-независимого скриптового языка.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lua является популярным языком для встраивания. Мы решили попробовать очевидный вариант. Документация выглядела многообещающе, однако под конец чтения главы &lt;a href="https://www.lua.org/pil/24.html"&gt;C API&lt;/a&gt; у нас не было ни малейшего представления, как наследовать класс C++ в Lua.&lt;/p&gt;
&lt;p&gt;Этот вопрос заставил нас найти библиотеку, которая смогла бы на него ответить: &lt;a href="http://sol2.rtfd.io"&gt;Sol2&lt;/a&gt;. Первая попытка вызвать функцию C++ из Lua провалилась. Правда, на этот раз наш вопрос был услышан, и &lt;a href="https://github.com/ThePhD/sol2/issues/465"&gt;мы получили ответ&lt;/a&gt;! Мы были сильно удивлены.
Далее мы попытались наследовать класс C++ в Lua, чтобы переопределить методы класса. Нам это не удалось с первого раза, но автор Sol2 &lt;a href="https://github.com/ThePhD/sol2/issues/468"&gt;снова помог нам&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В тот момент мы поняли, что это начало долгого и взаимовыгодного сотрудничества с Sol2/Lua.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Поиск скриптового языка открыл для нас следующую истину: люди важнее технологий.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Существует множество скриптовых языков, которые выглядят привлекательно на первый взгляд, но которые мертвы. Почему? Потому что у некоторых авторов нет времени на пользователей. В ответ пользователи предпочитают не тратить своё время на проекты подобных авторов.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем описание изучения скриптования в июле 2017.&lt;/p&gt;</content></entry><entry><title>OpenSceneGraph cross-platform guide</title><link href="https://kaisd.github.io/ogs-site/openscenegraph-cross-platform-guide.html" rel="alternate"></link><published>2017-07-17T00:00:00+03:00</published><updated>2017-07-17T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-07-17:/ogs-site/openscenegraph-cross-platform-guide.html</id><summary type="html">&lt;p&gt;&lt;img alt="OpenSceneGraph guide" src="https://kaisd.github.io/ogs-site/2017-07-openscenegraph-guide.png"&gt;&lt;/p&gt;
&lt;p&gt;This article summarizes the work we did to produce OpenSceneGraph cross-platform guide.&lt;/p&gt;
&lt;p&gt;June marked the finish of &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide"&gt;OpenSceneGraph cross-platform guide&lt;/a&gt; with the publishing of the last (initially planned) tutorial. The tutorial describes &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/tree/master/1.10.SampleWeb"&gt;how to build and run sample OpenSceneGraph application in Web&lt;/a&gt; using Emscripten.
In case you missed it, here's …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="OpenSceneGraph guide" src="https://kaisd.github.io/ogs-site/2017-07-openscenegraph-guide.png"&gt;&lt;/p&gt;
&lt;p&gt;This article summarizes the work we did to produce OpenSceneGraph cross-platform guide.&lt;/p&gt;
&lt;p&gt;June marked the finish of &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide"&gt;OpenSceneGraph cross-platform guide&lt;/a&gt; with the publishing of the last (initially planned) tutorial. The tutorial describes &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/tree/master/1.10.SampleWeb"&gt;how to build and run sample OpenSceneGraph application in Web&lt;/a&gt; using Emscripten.
In case you missed it, here's a &lt;a href="https://ogstudio.github.io/openscenegraph-cross-platform-guide/"&gt;link to the final application&lt;/a&gt;. Open it in your web browser.&lt;/p&gt;
&lt;p&gt;We started to compose the guide in February when we successfully managed to render a simple model on mobile and web.
We spent 120 hours in five months to produce ten tutorials of the guide.&lt;/p&gt;
&lt;p&gt;We have been doing OpenSceneGraph cross-platform guide for two main reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Keep OpenSceneGraph cross-platform knowledge in easily accessible and reproducible form&lt;/li&gt;
&lt;li&gt;Share the knowledge with OpenSceneGraph community to make it stronger&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We believe we succeeded in both. Here's why:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The guide repository has more &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/stargazers"&gt;stars&lt;/a&gt; (aka "likes") than any other repository of ours&lt;/li&gt;
&lt;li&gt;OpenSceneGraph project leader Robert Osfield said &lt;a href="http://www.mail-archive.com/osg-users@lists.openscenegraph.org/msg74815.html"&gt;"Great work"&lt;/a&gt;, which means a lot&lt;/li&gt;
&lt;li&gt;The guide already has &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/issues"&gt;two issues&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Reaching our goal of researching OpenSceneGraph cross-platform development and providing the knowledge back to the community just made us happier.&lt;/p&gt;
&lt;p&gt;However, our journey does not stop here. Using the knowledge of the guide, we now continue to work on bringing our tools to support mobile and web, just as we &lt;a href="http://opengamestudio.org/lang/en/news/2456"&gt;promised in January&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That's it for summarizing the work we did to produce OpenSceneGraph cross-platform guide.&lt;/p&gt;</content></entry><entry><title>OpenSceneGraph cross-platform guide</title><link href="https://kaisd.github.io/ogs-site/openscenegraph-cross-platform-guide-ru.html" rel="alternate"></link><published>2017-07-17T00:00:00+03:00</published><updated>2017-07-17T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-07-17:/ogs-site/openscenegraph-cross-platform-guide-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="OpenSceneGraph guide" src="https://kaisd.github.io/ogs-site/2017-07-openscenegraph-guide.png"&gt;&lt;/p&gt;
&lt;p&gt;Эта статья резюмирует создание кросс-платформенного руководства OpenSceneGraph.&lt;/p&gt;
&lt;p&gt;Июнь ознаменовал собой окончание работы над &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide"&gt;кросс-платформенным руководством OpenSceneGraph&lt;/a&gt;. Мы опубликовали последний самоучитель (из изначально запланированных). Этот самоучитель описывает &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/tree/master/1.10.SampleWeb"&gt;сборку и запуск примера приложения OpenSceneGraph в вебе&lt;/a&gt; с помощью Emscripten.
Если вы упустили этот самоучитель, то вот &lt;a href="https://ogstudio.github.io/openscenegraph-cross-platform-guide/"&gt;ссылка на приложение&lt;/a&gt; из него. Откройте …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="OpenSceneGraph guide" src="https://kaisd.github.io/ogs-site/2017-07-openscenegraph-guide.png"&gt;&lt;/p&gt;
&lt;p&gt;Эта статья резюмирует создание кросс-платформенного руководства OpenSceneGraph.&lt;/p&gt;
&lt;p&gt;Июнь ознаменовал собой окончание работы над &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide"&gt;кросс-платформенным руководством OpenSceneGraph&lt;/a&gt;. Мы опубликовали последний самоучитель (из изначально запланированных). Этот самоучитель описывает &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/tree/master/1.10.SampleWeb"&gt;сборку и запуск примера приложения OpenSceneGraph в вебе&lt;/a&gt; с помощью Emscripten.
Если вы упустили этот самоучитель, то вот &lt;a href="https://ogstudio.github.io/openscenegraph-cross-platform-guide/"&gt;ссылка на приложение&lt;/a&gt; из него. Откройте ссылку в веб-браузере.&lt;/p&gt;
&lt;p&gt;Мы начали составление руководства в феврале, как только нам удалось отобразить простую модель на мобилках и вебе.
Мы потратили 120 часов за пять месяцев на составление десяти самоучителей этого руководства.&lt;/p&gt;
&lt;p&gt;Создание кросс-платформенного руководства OpenSceneGraph преследовало две основные цели:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Сохранить знания о кросс-платформенной работе с OpenSceneGraph в легкодоступной и воспроизводимой форме&lt;/li&gt;
&lt;li&gt;Поделиться этим знанием с сообществом OpenSceneGraph и тем самым усилить сообщество&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Мы уверены в том, что нам удалось достичь обе цели. И вот почему:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Хранилище руководства получило больше &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/stargazers"&gt;звёзд&lt;/a&gt; (лайков), чем любое другое наше хранилище&lt;/li&gt;
&lt;li&gt;Robert Osfield, лидер проекта OpenSceneGraph, оценил руководство как &lt;a href="http://www.mail-archive.com/osg-users@lists.openscenegraph.org/msg74815.html"&gt;"отличную работу"&lt;/a&gt;; это значит для нас многое&lt;/li&gt;&lt;/li&gt;
&lt;li&gt;У руководства уже есть &lt;a href="https://github.com/OGStudio/openscenegraph-cross-platform-guide/issues"&gt;два тикета&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;В конце концов, мы просто рады тому факту, что изучили кросс-платформенную разработку с OpenSceneGraph и поделились этим знанием с сообществом.&lt;/p&gt;
&lt;p&gt;Тем не менее, наше путешествие на этом не окончено. Используя знания руководства, мы продолжаем работу над тем, чтобы добавить в свои инструменты поддержку мобилок и веба, как мы &lt;a href="http://opengamestudio.org/lang/ru/news/2456"&gt;обещали в январе&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем резюме о создании кросс-платформенного руководства OpenSceneGraph.&lt;/p&gt;</content></entry><entry><title>iOS tutorial</title><link href="https://kaisd.github.io/ogs-site/ios-tutorial.html" rel="alternate"></link><published>2017-06-08T10:00:00+03:00</published><updated>2017-06-08T10:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-06-08:/ogs-site/ios-tutorial.html</id><summary type="html">&lt;p&gt;&lt;img alt="iOS tutorial" src="https://kaisd.github.io/ogs-site/2017-06-08-ios-refactoring.png"&gt;&lt;/p&gt;
&lt;p&gt;This article describes problems we faced during the creation of iOS tutorial in May 2017.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twitter.com/OpenGameStudio/status/826816343433498627"&gt;This February&lt;/a&gt; we managed to get simple model rendered under iOS in just a few days. We expected to finish iOS tutorial in no time. However, the reality reminded us: it's easy to come up …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="iOS tutorial" src="https://kaisd.github.io/ogs-site/2017-06-08-ios-refactoring.png"&gt;&lt;/p&gt;
&lt;p&gt;This article describes problems we faced during the creation of iOS tutorial in May 2017.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twitter.com/OpenGameStudio/status/826816343433498627"&gt;This February&lt;/a&gt; we managed to get simple model rendered under iOS in just a few days. We expected to finish iOS tutorial in no time. However, the reality reminded us: it's easy to come up with a hackish demo that works for one person, but it's hard to create a concise example that works for everyone.&lt;/p&gt;
&lt;h3&gt;Native library&lt;/h3&gt;
&lt;p&gt;The first question we had to answer was: should the sample application be part of Xcode project or be a separately built library?&lt;/p&gt;
&lt;p&gt;We had to consider the following facts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Xcode project can use C++ directly (thanks to Objective-C++) without stuff like JNI&lt;ul&gt;
&lt;li&gt;There's no need for a separate library (+ application)&lt;/li&gt;
&lt;li&gt;Creating a separate library is an additional work (- library)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSceneGraph builds libraries&lt;ul&gt;
&lt;li&gt;It's easier to use standard build process (+ library)&lt;/li&gt;
&lt;li&gt;It's harder to create custom build process just for a single platform (- application)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSceneGraph uses CMake build system, which is not supported by Xcode&lt;ul&gt;
&lt;li&gt;Xcode project can't include CMake files (- application)&lt;/li&gt;
&lt;li&gt;It's easy to create custom CMake file that includes OpenSceneGraph CMake file to build a single library (+ library)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMake can generate Xcode project&lt;ul&gt;
&lt;li&gt;It's possible to create a CMake file that builds both OpenSceneGraph and the sample application (+ application)&lt;/li&gt;
&lt;li&gt;Xcode is the de-facto tool to create Xcode projects; it's easier to use standard build process (+ library)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After evaluating the pros and cons of each approach, we decided to turn the sample application into a library and include it in Xcode project. The downside of this approach is that simulator and real device builds need separate library builds.&lt;/p&gt;
&lt;h3&gt;Refactoring&lt;/h3&gt;
&lt;p&gt;The second question we had to answer was: should there be a single source code base for all platforms or several ones, one for each platform?&lt;/p&gt;
&lt;p&gt;While doing Android tutorial we used single source code base because it worked fine for desktop and Android. As we started to work through iOS tutorial, it became apparent that particular features may or may not work on some platforms. For example, one feature may work on desktop and iOS, but not Android. Another feature may work on iOS and Android, but not desktop. Since we didn't want to pollute the code with #ifdefs, we started to put each platform combination into a separate file. The number of files grew rapidly. The files were reusable, but it became extremely hard to see the whole picture.&lt;/p&gt;
&lt;p&gt;At this point, we realized there's the second question. We reminded ourselves that the main purpose of the sample source code is to teach how to do basic OpenSceneGraph things, not create a reusable library with API that is stable across several years.&lt;/p&gt;
&lt;p&gt;That's when our home grown feature tool came into play. With its help, we separated the code into several parts, which in the end produce just two files for each platform:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;functions.h - contains reusable classless functions&lt;/li&gt;
&lt;li&gt;main.h - contains the rest of the sample application code&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Their contents differ slightly for each platform, but it's easy to see the whole picture now.&lt;/p&gt;
&lt;p&gt;That's it for describing problems we faced during the creation of iOS tutorial in May 2017.&lt;/p&gt;</content></entry><entry><title>Самоучитель iOS</title><link href="https://kaisd.github.io/ogs-site/ios-tutorial-ru.html" rel="alternate"></link><published>2017-06-08T10:00:00+03:00</published><updated>2017-06-08T10:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-06-08:/ogs-site/ios-tutorial-ru.html</id><summary type="html">&lt;p&gt;&lt;img alt="Самоучитель iOS" src="https://kaisd.github.io/ogs-site/2017-06-08-ios-refactoring.png"&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает проблемы, с которыми мы столкнулись во время создания самоучителя для iOS в мае 2017.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twitter.com/OpenGameStudio/status/826816343433498627"&gt;В феврале&lt;/a&gt; мы сумели отобразить простую модель под iOS за считанные дни. Это дало нам уверенность, что самоучитель для iOS мы сделаем столь же быстро. Тем не менее, реальность напомнила нам о простой …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Самоучитель iOS" src="https://kaisd.github.io/ogs-site/2017-06-08-ios-refactoring.png"&gt;&lt;/p&gt;
&lt;p&gt;Эта статья описывает проблемы, с которыми мы столкнулись во время создания самоучителя для iOS в мае 2017.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twitter.com/OpenGameStudio/status/826816343433498627"&gt;В феврале&lt;/a&gt; мы сумели отобразить простую модель под iOS за считанные дни. Это дало нам уверенность, что самоучитель для iOS мы сделаем столь же быстро. Тем не менее, реальность напомнила нам о простой вещи: быстро сделать можно лишь поделку на коленке, работающую только у самого разработчика; над логически связанным примером, работающим у всех, придётся попотеть.&lt;/p&gt;
&lt;h3&gt;Нативная библиотека&lt;/h3&gt;
&lt;p&gt;Прежде всего нам необходимо было ответить на следующий вопрос: "должен ли пример приложения быть частью проекта Xcode или отдельной библиотекой?"&lt;/p&gt;
&lt;p&gt;Для принятия решения мы использовали следующие факты:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Проект Xcode может напрямую использовать C++ (благодаря Objective-C++) без прослоек вроде JNI&lt;ul&gt;
&lt;li&gt;Отдельная библиотека не нужна (+ приложение)&lt;/li&gt;
&lt;li&gt;Создание отдельной библиотеки - это дополнительная работа (- библиотека)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSceneGraph собирается в библиотеки&lt;ul&gt;
&lt;li&gt;Легче использовать стандартный процесс сборки (+ библиотека)&lt;/li&gt;
&lt;li&gt;Создавать свой процесс сборки лишь для одной платформы сложно (- приложение)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSceneGraph использует систему сборки CMake, которая не поддерживается Xcode&lt;ul&gt;
&lt;li&gt;Проект Xcode не может включать файлы CMake (- приложение)&lt;/li&gt;
&lt;li&gt;Свой файл CMake может с лёгкостью включить файл OpenSceneGraph CMake для сборки единой библиотеки (+ библиотека)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CMake может генерировать проект Xcode&lt;ul&gt;
&lt;li&gt;Можно создать файл CMake, который будет собирать как OpenSceneGraph, так и пример приложения (+ приложение)&lt;/li&gt;
&lt;li&gt;Xcode - это де-факто инструмент для создания проектов Xcode; легче использовать стандартный процесс сборки (+ библиотека)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Оценив плюсы и минусы обоих подходов, мы решили сделать библиотеку, которую можно включать в проект Xcode. Минусом данного подхода является то, что сборки приложения для симулятора и реального устройства используют разные сборки библиотеки.&lt;/p&gt;
&lt;h3&gt;Рефакторинг&lt;/h3&gt;
&lt;p&gt;Также нам пришлось ответить на ещё один вопрос: "использовать ли единую кодовую базу для всех платформ или несколько под каждую платформу?"&lt;/p&gt;
&lt;p&gt;При создании самоучителя для Android мы использовали единую кодовую базу, т.к. она отлично работала для десктопа и Android. Когда мы начали работу над самоучителем iOS, стало ясно, что часть функционала либо работает, либо не работает на некоторых платформах. Например, один функционал может работать на десктопе и iOS, но не работать на Android. Другой функционал может работать на iOS и Android, но не работать на десктопе. Т.к. мы не хотели загрязнять код кучей #ifdef, мы решили помещать функционал, специфичный для конкретной платформы или нескольких платформ, в разные файлы. Это привело к резкому увеличению количества файлов. Такой подход хорошо подходил для повторного использования, но совершенно не годился для понимания общей картины.&lt;/p&gt;
&lt;p&gt;В этот момент мы осознали необходимость ответа на второй вопрос. Мы напомнили себе, что главная цель примера приложения состоит в том, чтобы обучить базовым вещам OpenSceneGraph, а не создать повторно используемую библиотеку с API, который будет жить без изменений десятилетиями.&lt;/p&gt;
&lt;p&gt;Для ответа на этот вопрос нам помог наш внутренний инструмент feature tool. С его помощью мы разделили код на несколько частей, который в итоге собирается ровно в два файла для каждой платформы:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;functions.h - содержит повторно используемые бесклассовые функции&lt;/li&gt;
&lt;li&gt;main.h - содержит остальной код приложения&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Их содержимое несколько отличается для каждой из платформ, но наличие всего двух файлов позволяет увидеть общую картину.&lt;/p&gt;
&lt;p&gt;На этом мы заканчиваем описание проблем, с которыми мы столкнулись во время создания самоучителя для iOS в мае 2017.&lt;/p&gt;</content></entry><entry><title>Stub</title><link href="https://kaisd.github.io/ogs-site/stub.html" rel="alternate"></link><published>2017-06-03T00:00:00+03:00</published><updated>2017-06-03T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-06-03:/ogs-site/stub.html</id><summary type="html">&lt;p&gt;TODO Import previous Opensource Game Studio articles from Wordpress.&lt;/p&gt;</summary><content type="html">&lt;p&gt;TODO Import previous Opensource Game Studio articles from Wordpress.&lt;/p&gt;</content></entry><entry><title>Заглушка</title><link href="https://kaisd.github.io/ogs-site/stub-ru.html" rel="alternate"></link><published>2017-06-03T00:00:00+03:00</published><updated>2017-06-03T00:00:00+03:00</updated><author><name>Opensource Game Studio</name></author><id>tag:kaisd.github.io,2017-06-03:/ogs-site/stub-ru.html</id><summary type="html">&lt;p&gt;TODO Импортировать предыдущие статьи Opensource Game Studio с Wordpress.&lt;/p&gt;</summary><content type="html">&lt;p&gt;TODO Импортировать предыдущие статьи Opensource Game Studio с Wordpress.&lt;/p&gt;</content></entry></feed>